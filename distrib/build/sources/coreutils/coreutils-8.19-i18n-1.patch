Submitted by:            Matt Burgess (matthew_at_linuxfromscratch_dot_org)
Date:                    2012-05-13
Initial Package Version: 8.17
Upstream Status:         Rejected
Origin:                  Based on Fedora's i18n patch at 
  http://pkgs.fedoraproject.org/gitweb/?p=coreutils.git;a=blob;f=coreutils-i18n.patch
Description:             Fixes several i18n issues with various Coreutils programs

Repackaged for coreutils-8.19 on 2012-08-20

diff -Naur coreutils-8.19.orig/lib/linebuffer.h coreutils-8.19/lib/linebuffer.h
--- coreutils-8.19.orig/lib/linebuffer.h	2012-01-06 03:14:31.000000000 -0600
+++ coreutils-8.19/lib/linebuffer.h	2012-08-20 21:50:40.000000000 -0500
@@ -21,6 +21,11 @@
 
 # include <stdio.h>
 
+/* Get mbstate_t.  */
+# if HAVE_WCHAR_H
+#  include <wchar.h>
+# endif
+
 /* A 'struct linebuffer' holds a line of text. */
 
 struct linebuffer
@@ -28,6 +33,9 @@
   size_t size;                  /* Allocated. */
   size_t length;                /* Used. */
   char *buffer;
+# if HAVE_WCHAR_H
+  mbstate_t state;
+# endif
 };
 
 /* Initialize linebuffer LINEBUFFER for use. */
diff -Naur coreutils-8.19.orig/src/cut.c coreutils-8.19/src/cut.c
--- coreutils-8.19.orig/src/cut.c	2012-07-21 09:54:31.000000000 -0500
+++ coreutils-8.19/src/cut.c	2012-08-20 21:50:40.000000000 -0500
@@ -28,6 +28,11 @@
 #include <assert.h>
 #include <getopt.h>
 #include <sys/types.h>
+
+/* Get mbstate_t, mbrtowc().  */
+#if HAVE_WCHAR_H
+# include <wchar.h>
+#endif
 #include "system.h"
 
 #include "error.h"
@@ -37,6 +42,18 @@
 #include "quote.h"
 #include "xstrndup.h"
 
+/* MB_LEN_MAX is incorrectly defined to be 1 in at least one GCC
+   installation; work around this configuration error.        */
+#if !defined MB_LEN_MAX || MB_LEN_MAX < 2
+# undef MB_LEN_MAX
+# define MB_LEN_MAX 16
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HAVE_MBRTOWC && defined mbstate_t
+# define mbrtowc(pwc, s, n, ps) (mbrtowc) (pwc, s, n, 0)
+#endif
+
 /* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "cut"
 
@@ -72,6 +89,52 @@
     }							\
   while (0)
 
+/* Refill the buffer BUF to get a multibyte character. */
+#define REFILL_BUFFER(BUF, BUFPOS, BUFLEN, STREAM)                        \
+  do                                                                        \
+    {                                                                        \
+      if (BUFLEN < MB_LEN_MAX && !feof (STREAM) && !ferror (STREAM))        \
+        {                                                                \
+          memmove (BUF, BUFPOS, BUFLEN);                                \
+          BUFLEN += fread (BUF + BUFLEN, sizeof(char), BUFSIZ, STREAM); \
+          BUFPOS = BUF;                                                        \
+        }                                                                \
+    }                                                                        \
+  while (0)
+
+/* Get wide character on BUFPOS. BUFPOS is not included after that.
+   If byte sequence is not valid as a character, CONVFAIL is 1. Otherwise 0. */
+#define GET_NEXT_WC_FROM_BUFFER(WC, BUFPOS, BUFLEN, MBLENGTH, STATE, CONVFAIL) \
+  do                                                                        \
+    {                                                                        \
+      mbstate_t state_bak;                                                \
+                                                                        \
+      if (BUFLEN < 1)                                                        \
+        {                                                                \
+          WC = WEOF;                                                        \
+          break;                                                        \
+        }                                                                \
+                                                                        \
+      /* Get a wide character. */                                        \
+      CONVFAIL = 0;                                                        \
+      state_bak = STATE;                                                \
+      MBLENGTH = mbrtowc ((wchar_t *)&WC, BUFPOS, BUFLEN, &STATE);        \
+                                                                        \
+      switch (MBLENGTH)                                                        \
+        {                                                                \
+        case (size_t)-1:                                                \
+        case (size_t)-2:                                                \
+          CONVFAIL++;                                                        \
+          STATE = state_bak;                                                \
+          /* Fall througn. */                                                \
+                                                                        \
+        case 0:                                                                \
+          MBLENGTH = 1;                                                        \
+          break;                                                        \
+        }                                                                \
+    }                                                                        \
+  while (0)
+
 struct range_pair
   {
     size_t lo;
@@ -90,7 +153,7 @@
 /* The number of bytes allocated for FIELD_1_BUFFER.  */
 static size_t field_1_bufsize;
 
-/* The largest field or byte index used as an endpoint of a closed
+/* The largest byte, character or field index used as an endpoint of a closed
    or degenerate range specification;  this doesn't include the starting
    index of right-open-ended ranges.  For example, with either range spec
    '2-5,9-', '2-3,5,9-' this variable would be set to 5.  */
@@ -102,10 +165,11 @@
 
 /* This is a bit vector.
    In byte mode, which bytes to output.
+   In character mode, which characters to output.
    In field mode, which DELIM-separated fields to output.
-   Both bytes and fields are numbered starting with 1,
+   Bytes, characters and fields are numbered starting with 1,
    so the zeroth bit of this array is unused.
-   A field or byte K has been selected if
+   A byte, character or field K has been selected if
    (K <= MAX_RANGE_ENDPOINT and is_printable_field(K))
     || (EOL_RANGE_START > 0 && K >= EOL_RANGE_START).  */
 static unsigned char *printable_field;
@@ -114,15 +178,25 @@
   {
     undefined_mode,
 
-    /* Output characters that are in the given bytes. */
+    /* Output bytes that are at the given positions. */
     byte_mode,
 
+    /* Output characters that are at the given positions. */
+    character_mode,
+
     /* Output the given delimeter-separated fields. */
     field_mode
   };
 
 static enum operating_mode operating_mode;
 
+/* If nonzero, when in byte mode, don't split multibyte characters.  */
+static int byte_mode_character_aware;
+
+/* If nonzero, the function for single byte locale is work
+   if this program runs on multibyte locale. */
+static int force_singlebyte_mode;
+
 /* If true do not output lines containing no delimeter characters.
    Otherwise, all such lines are printed.  This option is valid only
    with field mode.  */
@@ -134,6 +208,9 @@
 
 /* The delimeter character for field mode. */
 static unsigned char delim;
+#if HAVE_WCHAR_H
+static wchar_t wcdelim;
+#endif
 
 /* True if the --output-delimiter=STRING option was specified.  */
 static bool output_delimiter_specified;
@@ -206,7 +283,7 @@
   -f, --fields=LIST       select only these fields;  also print any line\n\
                             that contains no delimiter character, unless\n\
                             the -s option is specified\n\
-  -n                      (ignored)\n\
+  -n                      with -b: don't split multibyte characters\n\
 "), stdout);
       fputs (_("\
       --complement        complement the set of selected bytes, characters\n\
@@ -365,7 +442,7 @@
           in_digits = false;
           /* Starting a range. */
           if (dash_found)
-            FATAL_ERROR (_("invalid byte or field list"));
+            FATAL_ERROR (_("invalid byte, character or field list"));
           dash_found = true;
           fieldstr++;
 
@@ -389,14 +466,16 @@
               if (!rhs_specified)
                 {
                   /* 'n-'.  From 'initial' to end of line. */
-                  eol_range_start = initial;
+                  if (eol_range_start == 0 ||
+                      (eol_range_start != 0 && eol_range_start > initial))
+                    eol_range_start = initial;
                   field_found = true;
                 }
               else
                 {
                   /* 'm-n' or '-n' (1-n). */
                   if (value < initial)
-                    FATAL_ERROR (_("invalid decreasing range"));
+                    FATAL_ERROR (_("invalid byte, character or field list"));
 
                   /* Is there already a range going to end of line? */
                   if (eol_range_start != 0)
@@ -476,6 +555,9 @@
               if (operating_mode == byte_mode)
                 error (0, 0,
                        _("byte offset %s is too large"), quote (bad_num));
+              else if (operating_mode == character_mode)
+                error (0, 0,
+                       _("character offset %s is too large"), quote (bad_num));
               else
                 error (0, 0,
                        _("field number %s is too large"), quote (bad_num));
@@ -486,7 +568,7 @@
           fieldstr++;
         }
       else
-        FATAL_ERROR (_("invalid byte or field list"));
+        FATAL_ERROR (_("invalid byte, character or field list"));
     }
 
   max_range_endpoint = 0;
@@ -581,6 +663,77 @@
     }
 }
 
+#if HAVE_MBRTOWC
+/* This function is in use for the following case.
+
+   1. Read from the stream STREAM, printing to standard output any selected
+   characters.
+
+   2. Read from stream STREAM, printing to standard output any selected bytes,
+   without splitting multibyte characters.  */
+
+static void
+cut_characters_or_cut_bytes_no_split (FILE *stream)
+{
+  int idx;                /* number of bytes or characters in the line so far. */
+  char buf[MB_LEN_MAX + BUFSIZ];  /* For spooling a read byte sequence. */
+  char *bufpos;                /* Next read position of BUF. */
+  size_t buflen;        /* The length of the byte sequence in buf. */
+  wint_t wc;                /* A gotten wide character. */
+  size_t mblength;        /* The byte size of a multibyte character which shows
+                           as same character as WC. */
+  mbstate_t state;        /* State of the stream. */
+  int convfail = 0;                /* 1, when conversion is failed. Otherwise 0. */
+  /* Whether to begin printing delimiters between ranges for the current line.
+     Set after we've begun printing data corresponding to the first range.  */
+  bool print_delimiter = false;
+
+  idx = 0;
+  buflen = 0;
+  bufpos = buf;
+  memset (&state, '\0', sizeof(mbstate_t));
+
+  while (1)
+    {
+      REFILL_BUFFER (buf, bufpos, buflen, stream);
+
+      GET_NEXT_WC_FROM_BUFFER (wc, bufpos, buflen, mblength, state, convfail);
+
+      if (wc == WEOF)
+        {
+          if (idx > 0)
+            putchar ('\n');
+          break;
+        }
+      else if (wc == L'\n')
+        {
+          putchar ('\n');
+          idx = 0;
+          print_delimiter = false;
+        }
+      else
+        {
+          bool range_start;
+          bool *rs = output_delimiter_specified ? &range_start : NULL;
+          idx += (operating_mode == byte_mode) ? mblength : 1;
+          if (print_kth (idx, rs))
+            {
+              if (rs && *rs && print_delimiter)
+                {
+                  fwrite (output_delimiter_string, sizeof (char),
+                         output_delimiter_length, stdout);
+               }
+              print_delimiter = true;
+              fwrite (bufpos, mblength, sizeof(char), stdout);
+            }
+        }
+
+      buflen -= mblength;
+      bufpos += mblength;
+    }
+}
+#endif
+
 /* Read from stream STREAM, printing to standard output any selected fields.  */
 
 static void
@@ -703,13 +856,195 @@
     }
 }
 
+#if HAVE_MBRTOWC
+static void
+cut_fields_mb (FILE *stream)
+{
+  int c;
+  unsigned int field_idx;
+  int found_any_selected_field;
+  int buffer_first_field;
+  int empty_input;
+  char buf[MB_LEN_MAX + BUFSIZ];  /* For spooling a read byte sequence. */
+  char *bufpos;                /* Next read position of BUF. */
+  size_t buflen;        /* The length of the byte sequence in buf. */
+  wint_t wc = 0;        /* A gotten wide character. */
+  size_t mblength;        /* The byte size of a multibyte character which shows
+                           as same character as WC. */
+  mbstate_t state;        /* State of the stream. */
+  int convfail = 0;                /* 1, when conversion is failed. Otherwise 0. */
+
+  found_any_selected_field = 0;
+  field_idx = 1;
+  bufpos = buf;
+  buflen = 0;
+  memset (&state, '\0', sizeof(mbstate_t));
+
+  c = getc (stream);
+  empty_input = (c == EOF);
+  if (c != EOF)
+  {
+    ungetc (c, stream);
+    wc = 0;
+  }
+  else
+    wc = WEOF;
+
+  /* To support the semantics of the -s flag, we may have to buffer
+     all of the first field to determine whether it is `delimited.'
+     But that is unnecessary if all non-delimited lines must be printed
+     and the first field has been selected, or if non-delimited lines
+     must be suppressed and the first field has *not* been selected.
+     That is because a non-delimited line has exactly one field.  */
+  buffer_first_field = (suppress_non_delimited ^ !print_kth (1, NULL));
+
+  while (1)
+    {
+      if (field_idx == 1 && buffer_first_field)
+        {
+          int len = 0;
+
+          while (1)
+            {
+              REFILL_BUFFER (buf, bufpos, buflen, stream);
+
+              GET_NEXT_WC_FROM_BUFFER
+                (wc, bufpos, buflen, mblength, state, convfail);
+
+              if (wc == WEOF)
+                break;
+
+              field_1_buffer = xrealloc (field_1_buffer, len + mblength);
+              memcpy (field_1_buffer + len, bufpos, mblength);
+              len += mblength;
+              buflen -= mblength;
+              bufpos += mblength;
+
+              if (!convfail && (wc == L'\n' || wc == wcdelim))
+                break;
+            }
+
+          if (wc == WEOF)
+            break;
+
+          /* If the first field extends to the end of line (it is not
+             delimited) and we are printing all non-delimited lines,
+             print this one.  */
+          if (convfail || (!convfail && wc != wcdelim))
+            {
+              if (suppress_non_delimited)
+                {
+                  /* Empty.        */
+                }
+              else
+                {
+                  fwrite (field_1_buffer, sizeof (char), len, stdout);
+                  /* Make sure the output line is newline terminated.  */
+                  if (convfail || (!convfail && wc != L'\n'))
+                    putchar ('\n');
+                }
+              continue;
+            }
+
+          if (print_kth (1, NULL))
+            {
+              /* Print the field, but not the trailing delimiter.  */
+              fwrite (field_1_buffer, sizeof (char), len - 1, stdout);
+              found_any_selected_field = 1;
+            }
+          ++field_idx;
+        }
+
+      if (wc != WEOF)
+        {
+          if (print_kth (field_idx, NULL))
+            {
+              if (found_any_selected_field)
+                {
+                  fwrite (output_delimiter_string, sizeof (char),
+                          output_delimiter_length, stdout);
+                }
+              found_any_selected_field = 1;
+            }
+
+          while (1)
+            {
+              REFILL_BUFFER (buf, bufpos, buflen, stream);
+
+              GET_NEXT_WC_FROM_BUFFER
+                (wc, bufpos, buflen, mblength, state, convfail);
+
+              if (wc == WEOF)
+                break;
+              else if (!convfail && (wc == wcdelim || wc == L'\n'))
+                {
+                  buflen -= mblength;
+                  bufpos += mblength;
+                  break;
+                }
+
+              if (print_kth (field_idx, NULL))
+                fwrite (bufpos, mblength, sizeof(char), stdout);
+
+              buflen -= mblength;
+              bufpos += mblength;
+            }
+        }
+
+      if ((!convfail || wc == L'\n') && buflen < 1)
+        wc = WEOF;
+
+      if (!convfail && wc == wcdelim)
+        ++field_idx;
+      else if (wc == WEOF || (!convfail && wc == L'\n'))
+        {
+          if (found_any_selected_field
+              || (!empty_input && !(suppress_non_delimited && field_idx == 1)))
+            putchar ('\n');
+          if (wc == WEOF)
+            break;
+          field_idx = 1;
+          found_any_selected_field = 0;
+        }
+    }
+}
+#endif
+
 static void
 cut_stream (FILE *stream)
 {
-  if (operating_mode == byte_mode)
-    cut_bytes (stream);
+#if HAVE_MBRTOWC
+  if (MB_CUR_MAX > 1 && !force_singlebyte_mode)
+    {
+      switch (operating_mode)
+        {
+        case byte_mode:
+          if (byte_mode_character_aware)
+            cut_characters_or_cut_bytes_no_split (stream);
+          else
+            cut_bytes (stream);
+          break;
+
+        case character_mode:
+          cut_characters_or_cut_bytes_no_split (stream);
+          break;
+
+        case field_mode:
+          cut_fields_mb (stream);
+          break;
+
+        default:
+          abort ();
+        }
+    }
   else
-    cut_fields (stream);
+#endif
+    {
+      if (operating_mode == field_mode)
+        cut_fields (stream);
+      else
+        cut_bytes (stream);
+    }
 }
 
 /* Process file FILE to standard output.
@@ -761,6 +1096,8 @@
   bool ok;
   bool delim_specified = false;
   char *spec_list_string IF_LINT ( = NULL);
+  char mbdelim[MB_LEN_MAX + 1];
+  size_t delimlen = 0;
 
   initialize_main (&argc, &argv);
   set_program_name (argv[0]);
@@ -783,7 +1120,6 @@
       switch (optc)
         {
         case 'b':
-        case 'c':
           /* Build the byte list. */
           if (operating_mode != undefined_mode)
             FATAL_ERROR (_("only one type of list may be specified"));
@@ -791,6 +1127,14 @@
           spec_list_string = optarg;
           break;
 
+        case 'c':
+          /* Build the character list. */
+          if (operating_mode != undefined_mode)
+            FATAL_ERROR (_("only one type of list may be specified"));
+          operating_mode = character_mode;
+          spec_list_string = optarg;
+          break;
+
         case 'f':
           /* Build the field list. */
           if (operating_mode != undefined_mode)
@@ -802,10 +1146,35 @@
         case 'd':
           /* New delimiter. */
           /* Interpret -d '' to mean 'use the NUL byte as the delimiter.'  */
-          if (optarg[0] != '\0' && optarg[1] != '\0')
-            FATAL_ERROR (_("the delimiter must be a single character"));
-          delim = optarg[0];
-          delim_specified = true;
+            {
+#if HAVE_MBRTOWC
+              if(MB_CUR_MAX > 1)
+                {
+                  mbstate_t state;
+
+                  memset (&state, '\0', sizeof(mbstate_t));
+                  delimlen = mbrtowc (&wcdelim, optarg, strnlen(optarg, MB_LEN_MAX), &state);
+
+                  if (delimlen == (size_t)-1 || delimlen == (size_t)-2)
+                    ++force_singlebyte_mode;
+                  else
+                    {
+                      delimlen = (delimlen < 1) ? 1 : delimlen;
+                      if (wcdelim != L'\0' && *(optarg + delimlen) != '\0')
+                        FATAL_ERROR (_("the delimiter must be a single character"));
+                      memcpy (mbdelim, optarg, delimlen);
+                    }
+                }
+
+              if (MB_CUR_MAX <= 1 || force_singlebyte_mode)
+#endif
+                {
+                  if (optarg[0] != '\0' && optarg[1] != '\0')
+                    FATAL_ERROR (_("the delimiter must be a single character"));
+                  delim = (unsigned char) optarg[0];
+                }
+            delim_specified = true;
+          }
           break;
 
         case OUTPUT_DELIMITER_OPTION:
@@ -818,6 +1187,7 @@
           break;
 
         case 'n':
+          byte_mode_character_aware = 1;
           break;
 
         case 's':
@@ -840,7 +1210,7 @@
   if (operating_mode == undefined_mode)
     FATAL_ERROR (_("you must specify a list of bytes, characters, or fields"));
 
-  if (delim != '\0' && operating_mode != field_mode)
+  if (delim_specified && operating_mode != field_mode)
     FATAL_ERROR (_("an input delimiter may be specified only\
  when operating on fields"));
 
@@ -867,15 +1237,34 @@
     }
 
   if (!delim_specified)
-    delim = '\t';
+    {
+      delim = '\t';
+#ifdef HAVE_MBRTOWC
+      wcdelim = L'\t';
+      mbdelim[0] = '\t';
+      mbdelim[1] = '\0';
+      delimlen = 1;
+#endif
+    }
 
   if (output_delimiter_string == NULL)
     {
-      static char dummy[2];
-      dummy[0] = delim;
-      dummy[1] = '\0';
-      output_delimiter_string = dummy;
-      output_delimiter_length = 1;
+#ifdef HAVE_MBRTOWC
+      if (MB_CUR_MAX > 1 && !force_singlebyte_mode)
+        {
+          output_delimiter_string = xstrdup(mbdelim);
+          output_delimiter_length = delimlen;
+        }
+
+      if (MB_CUR_MAX <= 1 || force_singlebyte_mode)
+#endif
+        {
+          static char dummy[2];
+          dummy[0] = delim;
+          dummy[1] = '\0';
+          output_delimiter_string = dummy;
+          output_delimiter_length = 1;
+        }
     }
 
   if (optind == argc)
diff -Naur coreutils-8.19.orig/src/expand.c coreutils-8.19/src/expand.c
--- coreutils-8.19.orig/src/expand.c	2012-07-21 09:54:31.000000000 -0500
+++ coreutils-8.19/src/expand.c	2012-08-20 21:50:40.000000000 -0500
@@ -37,12 +37,29 @@
 #include <stdio.h>
 #include <getopt.h>
 #include <sys/types.h>
+
+/* Get mbstate_t, mbrtowc(), wcwidth(). */
+#if HAVE_WCHAR_H
+# include <wchar.h>
+#endif
+
 #include "system.h"
 #include "error.h"
 #include "fadvise.h"
 #include "quote.h"
 #include "xstrndup.h"
 
+/* MB_LEN_MAX is incorrectly defined to be 1 in at least one GCC
+   installation; work around this configuration error.  */
+#if !defined MB_LEN_MAX || MB_LEN_MAX < 2
+# define MB_LEN_MAX 16
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HAVE_MBRTOWC && defined mbstate_t
+# define mbrtowc(pwc, s, n, ps) (mbrtowc) (pwc, s, n, 0)
+#endif
+
 /* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "expand"
 
@@ -358,6 +375,142 @@
     }
 }
 
+#if HAVE_MBRTOWC
+static void
+expand_multibyte (void)
+{
+  FILE *fp;			/* Input strem. */
+  mbstate_t i_state;		/* Current shift state of the input stream. */
+  mbstate_t i_state_bak;	/* Back up the I_STATE. */
+  mbstate_t o_state;		/* Current shift state of the output stream. */
+  char buf[MB_LEN_MAX + BUFSIZ];  /* For spooling a read byte sequence. */
+  char *bufpos = buf;			/* Next read position of BUF. */
+  size_t buflen = 0;		/* The length of the byte sequence in buf. */
+  wchar_t wc;			/* A gotten wide character. */
+  size_t mblength;		/* The byte size of a multibyte character
+				   which shows as same character as WC. */
+  int tab_index = 0;		/* Index in `tab_list' of next tabstop. */
+  int column = 0;		/* Column on screen of the next char. */
+  int next_tab_column;		/* Column the next tab stop is on. */
+  int convert = 1;		/* If nonzero, perform translations. */
+
+  fp = next_file ((FILE *) NULL);
+  if (fp == NULL)
+    return;
+
+  memset (&o_state, '\0', sizeof(mbstate_t));
+  memset (&i_state, '\0', sizeof(mbstate_t));
+
+  for (;;)
+    {
+      /* Refill the buffer BUF. */
+      if (buflen < MB_LEN_MAX && !feof(fp) && !ferror(fp))
+	{
+	  memmove (buf, bufpos, buflen);
+	  buflen += fread (buf + buflen, sizeof(char), BUFSIZ, fp);
+	  bufpos = buf;
+	}
+
+      /* No character is left in BUF. */
+      if (buflen < 1)
+	{
+	  fp = next_file (fp);
+
+	  if (fp == NULL)
+	    break;		/* No more files. */
+	  else
+	    {
+	      memset (&i_state, '\0', sizeof(mbstate_t));
+	      continue;
+	    }
+	}
+
+      /* Get a wide character. */
+      i_state_bak = i_state;
+      mblength = mbrtowc (&wc, bufpos, buflen, &i_state);
+
+      switch (mblength)
+	{
+	case (size_t)-1:	/* illegal byte sequence. */
+	case (size_t)-2:
+	  mblength = 1;
+	  i_state = i_state_bak;
+	  if (convert)
+	    {
+	      ++column;
+	      if (convert_entire_line == 0)
+		convert = 0;
+	    }
+	  putchar (*bufpos);
+	  break;
+
+	case 0:		/* null. */
+	  mblength = 1;
+	  if (convert && convert_entire_line == 0)
+	    convert = 0;
+	  putchar ('\0');
+	  break;
+
+	default:
+	  if (wc == L'\n')   /* LF. */
+	    {
+	      tab_index = 0;
+	      column = 0;
+	      convert = 1;
+	      putchar ('\n');
+	    }
+	  else if (wc == L'\t' && convert)	/* Tab. */
+	    {
+	      if (tab_size == 0)
+		{
+		  /* Do not let tab_index == first_free_tab;
+		     stop when it is 1 less. */
+		  while (tab_index < first_free_tab - 1
+		      && column >= tab_list[tab_index])
+		    tab_index++;
+		  next_tab_column = tab_list[tab_index];
+		  if (tab_index < first_free_tab - 1)
+		    tab_index++;
+		  if (column >= next_tab_column)
+		    next_tab_column = column + 1;
+		}
+	      else
+		next_tab_column = column + tab_size - column % tab_size;
+
+	      while (column < next_tab_column)
+		{
+		  putchar (' ');
+		  ++column;
+		}
+	    }
+	  else  /* Others. */
+	    {
+	      if (convert)
+		{
+		  if (wc == L'\b')
+		    {
+		      if (column > 0)
+			--column;
+		    }
+		  else
+		    {
+		      int width;		/* The width of WC. */
+
+		      width = wcwidth (wc);
+		      column += (width > 0) ? width : 0;
+		      if (convert_entire_line == 0)
+			convert = 0;
+		    }
+		}
+	      fwrite (bufpos, sizeof(char), mblength, stdout);
+	    }
+	}
+      buflen -= mblength;
+      bufpos += mblength;
+    }
+}
+#endif
+
 int
 main (int argc, char **argv)
 {
@@ -422,7 +575,12 @@
 
   file_list = (optind < argc ? &argv[optind] : stdin_argv);
 
-  expand ();
+#if HAVE_MBRTOWC
+  if (MB_CUR_MAX > 1)
+    expand_multibyte ();
+  else
+#endif
+    expand ();
 
   if (have_read_stdin && fclose (stdin) != 0)
     error (EXIT_FAILURE, errno, "-");
diff -Naur coreutils-8.19.orig/src/fold.c coreutils-8.19/src/fold.c
--- coreutils-8.19.orig/src/fold.c	2012-07-21 09:54:31.000000000 -0500
+++ coreutils-8.19/src/fold.c	2012-08-20 21:50:40.000000000 -0500
@@ -22,12 +22,34 @@
 #include <getopt.h>
 #include <sys/types.h>
 
+/* Get mbstate_t, mbrtowc(), wcwidth().  */
+#if HAVE_WCHAR_H
+# include <wchar.h>
+#endif
+
+/* Get iswprint(), iswblank(), wcwidth().  */
+#if HAVE_WCTYPE_H
+# include <wctype.h>
+#endif
+
 #include "system.h"
 #include "error.h"
 #include "fadvise.h"
 #include "quote.h"
 #include "xstrtol.h"
 
+/* MB_LEN_MAX is incorrectly defined to be 1 in at least one GCC
+      installation; work around this configuration error.  */
+#if !defined MB_LEN_MAX || MB_LEN_MAX < 2
+# undef MB_LEN_MAX
+# define MB_LEN_MAX 16
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HAVE_MBRTOWC && defined mbstate_t
+# define mbrtowc(pwc, s, n, ps) (mbrtowc) (pwc, s, n, 0)
+#endif
+
 #define TAB_WIDTH 8
 
 /* The official name of this program (e.g., no 'g' prefix).  */
@@ -35,20 +57,41 @@
 
 #define AUTHORS proper_name ("David MacKenzie")
 
+#define FATAL_ERROR(Message)                                            \
+  do                                                                    \
+    {                                                                   \
+      error (0, 0, (Message));                                          \
+      usage (2);                                                        \
+    }                                                                   \
+  while (0)
+
+enum operating_mode
+{
+  /* Fold texts by columns that are at the given positions. */
+  column_mode,
+
+  /* Fold texts by bytes that are at the given positions. */
+  byte_mode,
+
+  /* Fold texts by characters that are at the given positions. */
+  character_mode,
+};
+
+/* The argument shows current mode. (Default: column_mode) */
+static enum operating_mode operating_mode;
+
 /* If nonzero, try to break on whitespace. */
 static bool break_spaces;
 
-/* If nonzero, count bytes, not column positions. */
-static bool count_bytes;
-
 /* If nonzero, at least one of the files we read was standard input. */
 static bool have_read_stdin;
 
-static char const shortopts[] = "bsw:0::1::2::3::4::5::6::7::8::9::";
+static char const shortopts[] = "bcsw:0::1::2::3::4::5::6::7::8::9::";
 
 static struct option const longopts[] =
 {
   {"bytes", no_argument, NULL, 'b'},
+  {"characters", no_argument, NULL, 'c'},
   {"spaces", no_argument, NULL, 's'},
   {"width", required_argument, NULL, 'w'},
   {GETOPT_HELP_OPTION_DECL},
@@ -77,6 +120,7 @@
 "), stdout);
       fputs (_("\
   -b, --bytes         count bytes rather than columns\n\
+  -c, --characters    count characters rather than columns\n\
   -s, --spaces        break at spaces\n\
   -w, --width=WIDTH   use WIDTH columns instead of 80\n\
 "), stdout);
@@ -94,7 +138,7 @@
 static size_t
 adjust_column (size_t column, char c)
 {
-  if (!count_bytes)
+  if (operating_mode != byte_mode)
     {
       if (c == '\b')
         {
@@ -117,30 +161,14 @@
    to stdout, with maximum line length WIDTH.
    Return true if successful.  */
 
-static bool
-fold_file (char const *filename, size_t width)
+static void
+fold_text (FILE *istream, size_t width, int *saved_errno)
 {
-  FILE *istream;
   int c;
   size_t column = 0;		/* Screen column where next char will go. */
   size_t offset_out = 0;	/* Index in 'line_out' for next char. */
   static char *line_out = NULL;
   static size_t allocated_out = 0;
-  int saved_errno;
-
-  if (STREQ (filename, "-"))
-    {
-      istream = stdin;
-      have_read_stdin = true;
-    }
-  else
-    istream = fopen (filename, "r");
-
-  if (istream == NULL)
-    {
-      error (0, errno, "%s", filename);
-      return false;
-    }
 
   fadvise (istream, FADVISE_SEQUENTIAL);
 
@@ -170,6 +198,15 @@
               bool found_blank = false;
               size_t logical_end = offset_out;
 
+              /* If LINE_OUT has no wide character,
+                 put a new wide character in LINE_OUT
+                 if column is bigger than width. */
+              if (offset_out == 0)
+                {
+                  line_out[offset_out++] = c;
+                  continue;
+                }
+
               /* Look for the last blank. */
               while (logical_end)
                 {
@@ -216,11 +253,221 @@
       line_out[offset_out++] = c;
     }
 
-  saved_errno = errno;
+  *saved_errno = errno;
+
+  if (offset_out)
+    fwrite (line_out, sizeof (char), (size_t) offset_out, stdout);
+
+}
+
+#if HAVE_MBRTOWC
+static void
+fold_multibyte_text (FILE *istream, size_t width, int *saved_errno)
+{
+  char buf[MB_LEN_MAX + BUFSIZ];  /* For spooling a read byte sequence. */
+  size_t buflen = 0;        /* The length of the byte sequence in buf. */
+  char *bufpos = buf;         /* Next read position of BUF. */
+  wint_t wc;                /* A gotten wide character. */
+  size_t mblength;        /* The byte size of a multibyte character which shows
+                           as same character as WC. */
+  mbstate_t state, state_bak;        /* State of the stream. */
+  int convfail = 0;                /* 1, when conversion is failed. Otherwise 0. */
+
+  static char *line_out = NULL;
+  size_t offset_out = 0;        /* Index in `line_out' for next char. */
+  static size_t allocated_out = 0;
+
+  int increment;
+  size_t column = 0;
+
+  size_t last_blank_pos;
+  size_t last_blank_column;
+  int is_blank_seen;
+  int last_blank_increment = 0;
+  int is_bs_following_last_blank;
+  size_t bs_following_last_blank_num;
+  int is_cr_after_last_blank;
+
+#define CLEAR_FLAGS                                \
+   do                                                \
+     {                                                \
+        last_blank_pos = 0;                        \
+        last_blank_column = 0;                        \
+        is_blank_seen = 0;                        \
+        is_bs_following_last_blank = 0;                \
+        bs_following_last_blank_num = 0;        \
+        is_cr_after_last_blank = 0;                \
+     }                                                \
+   while (0)
+
+#define START_NEW_LINE                        \
+   do                                        \
+     {                                        \
+      putchar ('\n');                        \
+      column = 0;                        \
+      offset_out = 0;                        \
+      CLEAR_FLAGS;                        \
+    }                                        \
+   while (0)
+
+  CLEAR_FLAGS;
+  memset (&state, '\0', sizeof(mbstate_t));
+
+  for (;; bufpos += mblength, buflen -= mblength)
+    {
+      if (buflen < MB_LEN_MAX && !feof (istream) && !ferror (istream))
+        {
+          memmove (buf, bufpos, buflen);
+          buflen += fread (buf + buflen, sizeof(char), BUFSIZ, istream);
+          bufpos = buf;
+        }
+
+      if (buflen < 1)
+        break;
+
+      /* Get a wide character. */
+      state_bak = state;
+      mblength = mbrtowc ((wchar_t *)&wc, bufpos, buflen, &state);
+
+      switch (mblength)
+        {
+        case (size_t)-1:
+        case (size_t)-2:
+          convfail++;
+          state = state_bak;
+          /* Fall through. */
+
+        case 0:
+          mblength = 1;
+          break;
+        }
+
+rescan:
+      if (operating_mode == byte_mode)                        /* byte mode */
+        increment = mblength;
+      else if (operating_mode == character_mode)        /* character mode */
+        increment = 1;
+      else                                                /* column mode */
+        {
+          if (convfail)
+            increment = 1;
+          else
+            {
+              switch (wc)
+                {
+                case L'\n':
+                  fwrite (line_out, sizeof(char), offset_out, stdout);
+                  START_NEW_LINE;
+                  continue;
+                  
+                case L'\b':
+                  increment = (column > 0) ? -1 : 0;
+                  break;
+
+                case L'\r':
+                  increment = -1 * column;
+                  break;
+
+                case L'\t':
+                  increment = 8 - column % 8;
+                  break;
+
+                default:
+                  increment = wcwidth (wc);
+                  increment = (increment < 0) ? 0 : increment;
+                }
+            }
+        }
+
+      if (column + increment > width && break_spaces && last_blank_pos)
+        {
+          fwrite (line_out, sizeof(char), last_blank_pos, stdout);
+          putchar ('\n');
+
+          offset_out = offset_out - last_blank_pos;
+          column = column - last_blank_column + ((is_cr_after_last_blank)
+              ? last_blank_increment : bs_following_last_blank_num);
+          memmove (line_out, line_out + last_blank_pos, offset_out);
+          CLEAR_FLAGS;
+          goto rescan;
+        }
+
+      if (column + increment > width && column != 0)
+        {
+          fwrite (line_out, sizeof(char), offset_out, stdout);
+          START_NEW_LINE;
+          goto rescan;
+        }
+
+      if (allocated_out < offset_out + mblength)
+        {
+          line_out = X2REALLOC (line_out, &allocated_out);
+        }
+
+      memcpy (line_out + offset_out, bufpos, mblength);
+      offset_out += mblength;
+      column += increment;
+
+      if (is_blank_seen && !convfail && wc == L'\r')
+        is_cr_after_last_blank = 1;
+
+      if (is_bs_following_last_blank && !convfail && wc == L'\b')
+        ++bs_following_last_blank_num;
+      else
+        is_bs_following_last_blank = 0;
+
+      if (break_spaces && !convfail && iswblank (wc))
+        {
+          last_blank_pos = offset_out;
+          last_blank_column = column;
+          is_blank_seen = 1;
+          last_blank_increment = increment;
+          is_bs_following_last_blank = 1;
+          bs_following_last_blank_num = 0;
+          is_cr_after_last_blank = 0;
+        }
+    }
+
+  *saved_errno = errno;
 
   if (offset_out)
     fwrite (line_out, sizeof (char), (size_t) offset_out, stdout);
 
+}
+#endif
+
+/* Fold file FILENAME, or standard input if FILENAME is "-",
+   to stdout, with maximum line length WIDTH.
+   Return 0 if successful, 1 if an error occurs. */
+
+static bool
+fold_file (char *filename, size_t width)
+{
+  FILE *istream;
+  int saved_errno;
+
+  if (STREQ (filename, "-"))
+    {
+      istream = stdin;
+      have_read_stdin = 1;
+    }
+  else
+    istream = fopen (filename, "r");
+
+  if (istream == NULL)
+    {
+      error (0, errno, "%s", filename);
+      return 1;
+    }
+
+  /* Define how ISTREAM is being folded. */
+#if HAVE_MBRTOWC
+  if (MB_CUR_MAX > 1)
+    fold_multibyte_text (istream, width, &saved_errno);
+  else
+#endif
+    fold_text (istream, width, &saved_errno);
+
   if (ferror (istream))
     {
       error (0, saved_errno, "%s", filename);
@@ -253,7 +500,8 @@
 
   atexit (close_stdout);
 
-  break_spaces = count_bytes = have_read_stdin = false;
+  operating_mode = column_mode;
+  break_spaces = have_read_stdin = false;
 
   while ((optc = getopt_long (argc, argv, shortopts, longopts, NULL)) != -1)
     {
@@ -262,7 +510,15 @@
       switch (optc)
         {
         case 'b':		/* Count bytes rather than columns. */
-          count_bytes = true;
+          if (operating_mode != column_mode)
+            FATAL_ERROR (_("only one way of folding may be specified"));
+          operating_mode = byte_mode;
+          break;
+
+        case 'c':
+          if (operating_mode != column_mode)
+            FATAL_ERROR (_("only one way of folding may be specified"));
+          operating_mode = character_mode;
           break;
 
         case 's':		/* Break at word boundaries. */
diff -Naur coreutils-8.19.orig/src/join.c coreutils-8.19/src/join.c
--- coreutils-8.19.orig/src/join.c	2012-07-21 09:54:31.000000000 -0500
+++ coreutils-8.19/src/join.c	2012-08-20 21:50:40.000000000 -0500
@@ -22,18 +22,32 @@
 #include <sys/types.h>
 #include <getopt.h>
 
+/* Get mbstate_t, mbrtowc(), mbrtowc(), wcwidth().  */
+#if HAVE_WCHAR_H
+# include <wchar.h>
+#endif
+
+/* Get iswblank(), towupper.  */
+#if HAVE_WCTYPE_H
+# include <wctype.h>
+#endif
+
 #include "system.h"
 #include "error.h"
 #include "fadvise.h"
 #include "hard-locale.h"
 #include "linebuffer.h"
-#include "memcasecmp.h"
 #include "quote.h"
 #include "stdio--.h"
 #include "xmemcoll.h"
 #include "xstrtol.h"
 #include "argmatch.h"
 
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HAVE_MBRTOWC && defined mbstate_t
+# define mbrtowc(pwc, s, n, ps) (mbrtowc) (pwc, s, n, 0)
+#endif
+
 /* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "join"
 
@@ -135,10 +149,12 @@
 /* Last element in 'outlist', where a new element can be added.  */
 static struct outlist *outlist_end = &outlist_head;
 
-/* Tab character separating fields.  If negative, fields are separated
-   by any nonempty string of blanks, otherwise by exactly one
-   tab character whose value (when cast to unsigned char) equals TAB.  */
-static int tab = -1;
+/* Tab character separating fields.  If NULL, fields are separated
+   by any nonempty string of blanks.  */
+static char *tab = NULL;
+
+/* The number of bytes used for tab. */
+static size_t tablen = 0;
 
 /* If nonzero, check that the input is correctly ordered. */
 static enum
@@ -262,13 +278,14 @@
   if (ptr == lim)
     return;
 
-  if (0 <= tab && tab != '\n')
+  if (tab != NULL)
     {
+      unsigned char t = tab[0];
       char *sep;
-      for (; (sep = memchr (ptr, tab, lim - ptr)) != NULL; ptr = sep + 1)
+      for (; (sep = memchr (ptr, t, lim - ptr)) != NULL; ptr = sep + 1)
         extract_field (line, ptr, sep - ptr);
     }
-  else if (tab < 0)
+   else
     {
       /* Skip leading blanks before the first field.  */
       while (isblank (to_uchar (*ptr)))
@@ -292,6 +309,148 @@
   extract_field (line, ptr, lim - ptr);
 }
 
+#if HAVE_MBRTOWC
+static void
+xfields_multibyte (struct line *line)
+{
+  char *ptr = line->buf.buffer;
+  char const *lim = ptr + line->buf.length - 1;
+  wchar_t wc = 0;
+  size_t mblength = 1;
+  mbstate_t state, state_bak;
+
+  memset (&state, 0, sizeof (mbstate_t));
+
+  if (ptr >= lim)
+    return;
+
+  if (tab != NULL)
+    {
+      unsigned char t = tab[0];
+      char *sep = ptr;
+      for (; ptr < lim; ptr = sep + mblength)
+	{
+	  sep = ptr;
+	  while (sep < lim)
+	    {
+	      state_bak = state;
+	      mblength = mbrtowc (&wc, sep, lim - sep + 1, &state);
+
+	      if (mblength == (size_t)-1 || mblength == (size_t)-2)
+		{
+		  mblength = 1;
+		  state = state_bak;
+		}
+	      mblength = (mblength < 1) ? 1 : mblength;
+
+	      if (mblength == tablen && !memcmp (sep, tab, mblength))
+		break;
+	      else
+		{
+		  sep += mblength;
+		  continue;
+		}
+	    }
+
+	  if (sep >= lim)
+	    break;
+
+	  extract_field (line, ptr, sep - ptr);
+	}
+    }
+  else
+    {
+      /* Skip leading blanks before the first field.  */
+      while(ptr < lim)
+      {
+        state_bak = state;
+        mblength = mbrtowc (&wc, ptr, lim - ptr + 1, &state);
+
+        if (mblength == (size_t)-1 || mblength == (size_t)-2)
+          {
+            mblength = 1;
+            state = state_bak;
+            break;
+          }
+        mblength = (mblength < 1) ? 1 : mblength;
+
+        if (!iswblank(wc))
+          break;
+        ptr += mblength;
+      }
+
+      do
+	{
+	  char *sep;
+	  state_bak = state;
+	  mblength = mbrtowc (&wc, ptr, lim - ptr + 1, &state);
+	  if (mblength == (size_t)-1 || mblength == (size_t)-2)
+	    {
+	      mblength = 1;
+	      state = state_bak;
+	      break;
+	    }
+	  mblength = (mblength < 1) ? 1 : mblength;
+
+	  sep = ptr + mblength;
+	  while (sep < lim)
+	    {
+	      state_bak = state;
+	      mblength = mbrtowc (&wc, sep, lim - sep + 1, &state);
+	      if (mblength == (size_t)-1 || mblength == (size_t)-2)
+		{
+		  mblength = 1;
+		  state = state_bak;
+		  break;
+		}
+	      mblength = (mblength < 1) ? 1 : mblength;
+
+	      if (iswblank (wc))
+		break;
+
+	      sep += mblength;
+	    }
+
+	  extract_field (line, ptr, sep - ptr);
+	  if (sep >= lim)
+	    return;
+
+	  state_bak = state;
+	  mblength = mbrtowc (&wc, sep, lim - sep + 1, &state);
+	  if (mblength == (size_t)-1 || mblength == (size_t)-2)
+	    {
+	      mblength = 1;
+	      state = state_bak;
+	      break;
+	    }
+	  mblength = (mblength < 1) ? 1 : mblength;
+
+	  ptr = sep + mblength;
+	  while (ptr < lim)
+	    {
+	      state_bak = state;
+	      mblength = mbrtowc (&wc, ptr, lim - ptr + 1, &state);
+	      if (mblength == (size_t)-1 || mblength == (size_t)-2)
+		{
+		  mblength = 1;
+		  state = state_bak;
+		  break;
+		}
+	      mblength = (mblength < 1) ? 1 : mblength;
+
+	      if (!iswblank (wc))
+		break;
+
+	      ptr += mblength;
+	    }
+	}
+      while (ptr < lim);
+    }
+
+  extract_field (line, ptr, lim - ptr);
+}
+#endif
+ 
 static void
 freeline (struct line *line)
 {
@@ -313,56 +472,115 @@
         size_t jf_1, size_t jf_2)
 {
   /* Start of field to compare in each file.  */
-  char *beg1;
-  char *beg2;
-
-  size_t len1;
-  size_t len2;		/* Length of fields to compare.  */
+  char *beg[2];
+  char *copy[2];
+  size_t len[2]; 	/* Length of fields to compare.  */
   int diff;
+  int i, j;
 
   if (jf_1 < line1->nfields)
     {
-      beg1 = line1->fields[jf_1].beg;
-      len1 = line1->fields[jf_1].len;
+      beg[0] = line1->fields[jf_1].beg;
+      len[0] = line1->fields[jf_1].len;
     }
   else
     {
-      beg1 = NULL;
-      len1 = 0;
+      beg[0] = NULL;
+      len[0] = 0;
     }
 
   if (jf_2 < line2->nfields)
     {
-      beg2 = line2->fields[jf_2].beg;
-      len2 = line2->fields[jf_2].len;
+      beg[1] = line2->fields[jf_2].beg;
+      len[1] = line2->fields[jf_2].len;
     }
   else
     {
-      beg2 = NULL;
-      len2 = 0;
+      beg[1] = NULL;
+      len[1] = 0;
     }
 
-  if (len1 == 0)
-    return len2 == 0 ? 0 : -1;
-  if (len2 == 0)
+  if (len[0] == 0)
+    return len[1] == 0 ? 0 : -1;
+  if (len[1] == 0)
     return 1;
 
   if (ignore_case)
     {
-      /* FIXME: ignore_case does not work with NLS (in particular,
-         with multibyte chars).  */
-      diff = memcasecmp (beg1, beg2, MIN (len1, len2));
+#ifdef HAVE_MBRTOWC
+      if (MB_CUR_MAX > 1)
+      {
+        size_t mblength;
+        wchar_t wc, uwc;
+        mbstate_t state, state_bak;
+
+        memset (&state, '\0', sizeof (mbstate_t));
+
+        for (i = 0; i < 2; i++)
+          {
+            copy[i] = alloca (len[i] + 1);
+
+            for (j = 0; j < MIN (len[0], len[1]);)
+              {
+                state_bak = state;
+                mblength = mbrtowc (&wc, beg[i] + j, len[i] - j, &state);
+
+                switch (mblength)
+                  {
+                  case (size_t) -1:
+                  case (size_t) -2:
+                    state = state_bak;
+                    /* Fall through */
+                  case 0:
+                    mblength = 1;
+                    break;
+
+                  default:
+                    uwc = towupper (wc);
+
+                    if (uwc != wc)
+                      {
+                        mbstate_t state_wc;
+
+                        memset (&state_wc, '\0', sizeof (mbstate_t));
+                        wcrtomb (copy[i] + j, uwc, &state_wc);
+                      }
+                    else
+                      memcpy (copy[i] + j, beg[i] + j, mblength);
+                  }
+                j += mblength;
+              }
+            copy[i][j] = '\0';
+          }
+      }
+      else
+#endif
+      {
+        for (i = 0; i < 2; i++)
+          {
+            copy[i] = alloca (len[i] + 1);
+
+            for (j = 0; j < MIN (len[0], len[1]); j++)
+              copy[i][j] = toupper (beg[i][j]);
+
+            copy[i][j] = '\0';
+          }
+      }
     }
   else
     {
-      if (hard_LC_COLLATE)
-        return xmemcoll (beg1, len1, beg2, len2);
-      diff = memcmp (beg1, beg2, MIN (len1, len2));
+      copy[0] = (unsigned char *) beg[0];
+      copy[1] = (unsigned char *) beg[1];
     }
 
+  if (hard_LC_COLLATE)
+    return xmemcoll ((char *) copy[0], len[0], (char *) copy[1], len[1]);
+  diff = memcmp (copy[0], copy[1], MIN (len[0], len[1]));
+
+
   if (diff)
     return diff;
-  return len1 < len2 ? -1 : len1 != len2;
+  return len[0] - len[1];
 }
 
 /* Check that successive input lines PREV and CURRENT from input file
@@ -454,6 +672,11 @@
     }
   ++line_no[which - 1];
 
+#if HAVE_MBRTOWC
+  if (MB_CUR_MAX > 1)
+    xfields_multibyte (line);
+  else
+#endif
   xfields (line);
 
   if (prevline[which - 1])
@@ -553,21 +776,28 @@
 
 /* Output all the fields in line, other than the join field.  */
 
+#define PUT_TAB_CHAR							\
+  do									\
+    {									\
+      (tab != NULL) ?							\
+	fwrite(tab, sizeof(char), tablen, stdout) : putchar (' ');	\
+    }									\
+  while (0)
+
 static void
 prfields (struct line const *line, size_t join_field, size_t autocount)
 {
   size_t i;
   size_t nfields = autoformat ? autocount : line->nfields;
-  char output_separator = tab < 0 ? ' ' : tab;
 
   for (i = 0; i < join_field && i < nfields; ++i)
     {
-      putchar (output_separator);
+      PUT_TAB_CHAR;
       prfield (i, line);
     }
   for (i = join_field + 1; i < nfields; ++i)
     {
-      putchar (output_separator);
+      PUT_TAB_CHAR;
       prfield (i, line);
     }
 }
@@ -578,7 +808,6 @@
 prjoin (struct line const *line1, struct line const *line2)
 {
   const struct outlist *outlist;
-  char output_separator = tab < 0 ? ' ' : tab;
   size_t field;
   struct line const *line;
 
@@ -612,7 +841,7 @@
           o = o->next;
           if (o == NULL)
             break;
-          putchar (output_separator);
+          PUT_TAB_CHAR;
         }
       putchar ('\n');
     }
@@ -1090,21 +1319,46 @@
 
         case 't':
           {
-            unsigned char newtab = optarg[0];
+            char *newtab = NULL;
+            size_t newtablen;
+            newtab = xstrdup (optarg);
+#if HAVE_MBRTOWC
+            if (MB_CUR_MAX > 1)
+              {
+                mbstate_t state;
+
+                memset (&state, 0, sizeof (mbstate_t));
+                newtablen = mbrtowc (NULL, newtab,
+                                     strnlen (newtab, MB_LEN_MAX),
+                                     &state);
+                if (newtablen == (size_t) 0
+                    || newtablen == (size_t) -1
+                    || newtablen == (size_t) -2)
+                  newtablen = 1;
+              }
+            else
+#endif
+              newtablen = 1;
             if (! newtab)
-              newtab = '\n'; /* '' => process the whole line.  */
+            {
+              newtab = "\n"; /* '' => process the whole line.  */
+            }
             else if (optarg[1])
               {
-                if (STREQ (optarg, "\\0"))
-                  newtab = '\0';
-                else
-                  error (EXIT_FAILURE, 0, _("multi-character tab %s"),
-                         quote (optarg));
+                if (newtablen == 1 && newtab[1])
+                {
+                  if (STREQ (newtab, "\\0"))
+                     newtab[0] = '\0';
+                }
+              }
+            if (tab != NULL && strcmp (tab, newtab))
+              {
+                free (newtab);
+                error (EXIT_FAILURE, 0, _("incompatible tabs"));
               }
-            if (0 <= tab && tab != newtab)
-              error (EXIT_FAILURE, 0, _("incompatible tabs"));
             tab = newtab;
-          }
+            tablen = newtablen;
+           }
           break;
 
         case NOCHECK_ORDER_OPTION:
diff -Naur coreutils-8.19.orig/src/pr.c coreutils-8.19/src/pr.c
--- coreutils-8.19.orig/src/pr.c	2012-07-21 09:54:31.000000000 -0500
+++ coreutils-8.19/src/pr.c	2012-08-20 21:50:40.000000000 -0500
@@ -312,6 +312,32 @@
 
 #include <getopt.h>
 #include <sys/types.h>
+
+/* Get MB_LEN_MAX.  */
+#include <limits.h>
+/* MB_LEN_MAX is incorrectly defined to be 1 in at least one GCC
+   installation; work around this configuration error.  */
+#if !defined MB_LEN_MAX || MB_LEN_MAX == 1
+# define MB_LEN_MAX 16
+#endif
+
+/* Get MB_CUR_MAX.  */
+#include <stdlib.h>
+
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
+/* Get mbstate_t, mbrtowc(), wcwidth().  */
+#if HAVE_WCHAR_H
+# include <wchar.h>
+#endif
+
+/* Get iswprint(). -- for wcwidth().  */
+#if HAVE_WCTYPE_H
+# include <wctype.h>
+#endif
+#if !defined iswprint && !HAVE_ISWPRINT
+# define iswprint(wc) 1
+#endif
+
 #include "system.h"
 #include "error.h"
 #include "fadvise.h"
@@ -323,6 +349,18 @@
 #include "strftime.h"
 #include "xstrtol.h"
 
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HAVE_MBRTOWC && defined mbstate_t
+# define mbrtowc(pwc, s, n, ps) (mbrtowc) (pwc, s, n, 0)
+#endif
+
+#ifndef HAVE_DECL_WCWIDTH
+"this configure-time declaration test was not run"
+#endif
+#if !HAVE_DECL_WCWIDTH
+extern int wcwidth ();
+#endif
+
 /* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "pr"
 
@@ -415,7 +453,20 @@
 
 typedef struct COLUMN COLUMN;
 
-static int char_to_clump (char c);
+/* Funtion pointers to switch functions for single byte locale or for
+   multibyte locale. If multibyte functions do not exist in your sysytem,
+   these pointers always point the function for single byte locale. */
+static void (*print_char) (char c);
+static int (*char_to_clump) (char c);
+
+/* Functions for single byte locale. */
+static void print_char_single (char c);
+static int char_to_clump_single (char c);
+
+/* Functions for multibyte locale. */
+static void print_char_multi (char c);
+static int char_to_clump_multi (char c);
+
 static bool read_line (COLUMN *p);
 static bool print_page (void);
 static bool print_stored (COLUMN *p);
@@ -425,6 +476,7 @@
 static void pad_across_to (int position);
 static void add_line_number (COLUMN *p);
 static void getoptarg (char *arg, char switch_char, char *character,
+                       int *character_length, int *character_width,
                        int *number);
 static void print_files (int number_of_files, char **av);
 static void init_parameters (int number_of_files);
@@ -438,7 +490,6 @@
 static void pad_down (int lines);
 static void read_rest_of_line (COLUMN *p);
 static void skip_read (COLUMN *p, int column_number);
-static void print_char (char c);
 static void cleanup (void);
 static void print_sep_string (void);
 static void separator_string (const char *optarg_S);
@@ -450,7 +501,7 @@
    we store the leftmost columns contiguously in buff.
    To print a line from buff, get the index of the first character
    from line_vector[i], and print up to line_vector[i + 1]. */
-static char *buff;
+static unsigned char *buff;
 
 /* Index of the position in buff where the next character
    will be stored. */
@@ -554,7 +605,7 @@
 static bool untabify_input = false;
 
 /* (-e) The input tab character. */
-static char input_tab_char = '\t';
+static char input_tab_char[MB_LEN_MAX] = "\t";
 
 /* (-e) Tabstops are at chars_per_tab, 2*chars_per_tab, 3*chars_per_tab, ...
    where the leftmost column is 1. */
@@ -564,7 +615,10 @@
 static bool tabify_output = false;
 
 /* (-i) The output tab character. */
-static char output_tab_char = '\t';
+static char output_tab_char[MB_LEN_MAX] = "\t";
+
+/* (-i) The byte length of output tab character. */
+static int output_tab_char_length = 1;
 
 /* (-i) The width of the output tab. */
 static int chars_per_output_tab = 8;
@@ -638,7 +692,13 @@
 static bool numbered_lines = false;
 
 /* (-n) Character which follows each line number. */
-static char number_separator = '\t';
+static char number_separator[MB_LEN_MAX] = "\t";
+
+/* (-n) The byte length of the character which follows each line number. */
+static int number_separator_length = 1;
+
+/* (-n) The character width of the character which follows each line number. */
+static int number_separator_width = 0;
 
 /* (-n) line counting starts with 1st line of input file (not with 1st
    line of 1st page printed). */
@@ -691,6 +751,7 @@
    -a|COLUMN|-m is a 'space' and with the -J option a 'tab'. */
 static char *col_sep_string = (char *) "";
 static int col_sep_length = 0;
+static int col_sep_width = 0;
 static char *column_separator = (char *) " ";
 static char *line_separator = (char *) "\t";
 
@@ -847,6 +908,13 @@
   col_sep_length = (int) strlen (optarg_S);
   col_sep_string = xmalloc (col_sep_length + 1);
   strcpy (col_sep_string, optarg_S);
+
+#if HAVE_MBRTOWC
+  if (MB_CUR_MAX > 1)
+    col_sep_width = mbswidth (col_sep_string, 0);
+  else
+#endif
+    col_sep_width = col_sep_length;
 }
 
 int
@@ -871,6 +939,21 @@
 
   atexit (close_stdout);
 
+/* Define which functions are used, the ones for single byte locale or the ones
+   for multibyte locale. */
+#if HAVE_MBRTOWC
+  if (MB_CUR_MAX > 1)
+    {
+      print_char = print_char_multi;
+      char_to_clump = char_to_clump_multi;
+    }
+  else
+#endif
+    {
+      print_char = print_char_single;
+      char_to_clump = char_to_clump_single;
+    }
+
   n_files = 0;
   file_names = (argc > 1
                 ? xmalloc ((argc - 1) * sizeof (char *))
@@ -947,8 +1030,12 @@
           break;
         case 'e':
           if (optarg)
-            getoptarg (optarg, 'e', &input_tab_char,
-                       &chars_per_input_tab);
+            {
+              int dummy_length, dummy_width;
+
+              getoptarg (optarg, 'e', input_tab_char, &dummy_length,
+                         &dummy_width, &chars_per_input_tab);
+            }
           /* Could check tab width > 0. */
           untabify_input = true;
           break;
@@ -961,8 +1048,12 @@
           break;
         case 'i':
           if (optarg)
-            getoptarg (optarg, 'i', &output_tab_char,
-                       &chars_per_output_tab);
+            {
+              int dummy_width;
+
+              getoptarg (optarg, 'i', output_tab_char, &output_tab_char_length,
+                         &dummy_width, &chars_per_output_tab);
+            }
           /* Could check tab width > 0. */
           tabify_output = true;
           break;
@@ -989,8 +1080,8 @@
         case 'n':
           numbered_lines = true;
           if (optarg)
-            getoptarg (optarg, 'n', &number_separator,
-                       &chars_per_number);
+            getoptarg (optarg, 'n', number_separator, &number_separator_length,
+                       &number_separator_width, &chars_per_number);
           break;
         case 'N':
           skip_count = false;
@@ -1029,7 +1120,7 @@
           old_s = false;
           /* Reset an additional input of -s, -S dominates -s */
           col_sep_string = bad_cast ("");
-          col_sep_length = 0;
+          col_sep_length = col_sep_width = 0;
           use_col_separator = true;
           if (optarg)
             separator_string (optarg);
@@ -1186,10 +1277,45 @@
    a number. */
 
 static void
-getoptarg (char *arg, char switch_char, char *character, int *number)
+getoptarg (char *arg, char switch_char, char *character, int *character_length,
+           int *character_width, int *number)
 {
   if (!ISDIGIT (*arg))
-    *character = *arg++;
+    {
+#ifdef HAVE_MBRTOWC
+      if (MB_CUR_MAX > 1)        /* for multibyte locale. */
+        {
+          wchar_t wc;
+          size_t mblength;
+          int width;
+          mbstate_t state = {'\0'};
+
+          mblength = mbrtowc (&wc, arg, strnlen(arg, MB_LEN_MAX), &state);
+
+          if (mblength == (size_t)-1 || mblength == (size_t)-2)
+            {
+              *character_length = 1;
+              *character_width = 1;
+            }
+          else
+            {
+              *character_length = (mblength < 1) ? 1 : mblength;
+              width = wcwidth (wc);
+              *character_width = (width < 0) ? 0 : width;
+            }
+
+          strncpy (character, arg, *character_length);
+          arg += *character_length;
+        }
+      else                        /* for single byte locale. */
+#endif
+        {
+          *character = *arg++;
+          *character_length = 1;
+          *character_width = 1;
+        }
+    }
+
   if (*arg)
     {
       long int tmp_long;
@@ -1211,6 +1337,11 @@
 init_parameters (int number_of_files)
 {
   int chars_used_by_number = 0;
+  int mb_len = 1;
+#if HAVE_MBRTOWC
+  if (MB_CUR_MAX > 1)
+    mb_len = MB_LEN_MAX;
+#endif
 
   lines_per_body = lines_per_page - lines_per_header - lines_per_footer;
   if (lines_per_body <= 0)
@@ -1248,7 +1379,7 @@
           else
             col_sep_string = column_separator;
 
-          col_sep_length = 1;
+          col_sep_length = col_sep_width = 1;
           use_col_separator = true;
         }
       /* It's rather pointless to define a TAB separator with column
@@ -1279,11 +1410,11 @@
              + TAB_WIDTH (chars_per_input_tab, chars_per_number);   */
 
       /* Estimate chars_per_text without any margin and keep it constant. */
-      if (number_separator == '\t')
+      if (number_separator[0] == '\t')
         number_width = (chars_per_number
                         + TAB_WIDTH (chars_per_default_tab, chars_per_number));
       else
-        number_width = chars_per_number + 1;
+        number_width = chars_per_number + number_separator_width;
 
       /* The number is part of the column width unless we are
          printing files in parallel. */
@@ -1298,7 +1429,7 @@
     }
 
   chars_per_column = (chars_per_line - chars_used_by_number
-                      - (columns - 1) * col_sep_length) / columns;
+                      - (columns - 1) * col_sep_width) / columns;
 
   if (chars_per_column < 1)
     error (EXIT_FAILURE, 0, _("page width too narrow"));
@@ -1315,7 +1446,7 @@
      We've to use 8 as the lower limit, if we use chars_per_default_tab = 8
      to expand a tab which is not an input_tab-char. */
   free (clump_buff);
-  clump_buff = xmalloc (MAX (8, chars_per_input_tab));
+  clump_buff = xmalloc (mb_len * MAX (8, chars_per_input_tab));
 }
 
 /* Open the necessary files,
@@ -1423,7 +1554,7 @@
 
   /* Enlarge p->start_position of first column to use the same form of
      padding_not_printed with all columns. */
-  h = h + col_sep_length;
+  h = h + col_sep_width;
 
   /* This loop takes care of all but the rightmost column. */
 
@@ -1457,7 +1588,7 @@
         }
       else
         {
-          h = h_next + col_sep_length;
+          h = h_next + col_sep_width;
           h_next = h + chars_per_column;
         }
     }
@@ -1748,9 +1879,9 @@
 align_column (COLUMN *p)
 {
   padding_not_printed = p->start_position;
-  if (padding_not_printed - col_sep_length > 0)
+  if (padding_not_printed - col_sep_width > 0)
     {
-      pad_across_to (padding_not_printed - col_sep_length);
+      pad_across_to (padding_not_printed - col_sep_width);
       padding_not_printed = ANYWHERE;
     }
 
@@ -2021,13 +2152,13 @@
       /* May be too generous. */
       buff = X2REALLOC (buff, &buff_allocated);
     }
-  buff[buff_current++] = c;
+  buff[buff_current++] = (unsigned char) c;
 }
 
 static void
 add_line_number (COLUMN *p)
 {
-  int i;
+  int i, j;
   char *s;
   int left_cut;
 
@@ -2050,22 +2181,24 @@
       /* Tabification is assumed for multiple columns, also for n-separators,
          but 'default n-separator = TAB' hasn't been given priority over
          equal column_width also specified by POSIX. */
-      if (number_separator == '\t')
+      if (number_separator[0] == '\t')
         {
           i = number_width - chars_per_number;
           while (i-- > 0)
             (p->char_func) (' ');
         }
       else
-        (p->char_func) (number_separator);
+        for (j = 0; j < number_separator_length; j++)
+          (p->char_func) (number_separator[j]);
     }
   else
     /* To comply with POSIX, we avoid any expansion of default TAB
        separator with a single column output. No column_width requirement
        has to be considered. */
     {
-      (p->char_func) (number_separator);
-      if (number_separator == '\t')
+      for (j = 0; j < number_separator_length; j++)
+        (p->char_func) (number_separator[j]);
+      if (number_separator[0] == '\t')
         output_position = POS_AFTER_TAB (chars_per_output_tab,
                           output_position);
     }
@@ -2226,7 +2359,7 @@
   while (goal - h_old > 1
          && (h_new = POS_AFTER_TAB (chars_per_output_tab, h_old)) <= goal)
     {
-      putchar (output_tab_char);
+      fwrite (output_tab_char, sizeof(char), output_tab_char_length, stdout);
       h_old = h_new;
     }
   while (++h_old <= goal)
@@ -2246,6 +2379,7 @@
 {
   char *s;
   int l = col_sep_length;
+  int not_space_flag;
 
   s = col_sep_string;
 
@@ -2259,6 +2393,7 @@
     {
       for (; separators_not_printed > 0; --separators_not_printed)
         {
+          not_space_flag = 0;
           while (l-- > 0)
             {
               /* 3 types of sep_strings: spaces only, spaces and chars,
@@ -2272,12 +2407,15 @@
                 }
               else
                 {
+                  not_space_flag = 1;
                   if (spaces_not_printed > 0)
                     print_white_space ();
                   putchar (*s++);
-                  ++output_position;
                 }
             }
+          if (not_space_flag)
+            output_position += col_sep_width;
+
           /* sep_string ends with some spaces */
           if (spaces_not_printed > 0)
             print_white_space ();
@@ -2305,7 +2443,7 @@
    required number of tabs and spaces. */
 
 static void
-print_char (char c)
+print_char_single (char c)
 {
   if (tabify_output)
     {
@@ -2329,6 +2467,74 @@
   putchar (c);
 }
 
+#ifdef HAVE_MBRTOWC
+static void
+print_char_multi (char c)
+{
+  static size_t mbc_pos = 0;
+  static char mbc[MB_LEN_MAX] = {'\0'};
+  static mbstate_t state = {'\0'};
+  mbstate_t state_bak;
+  wchar_t wc;
+  size_t mblength;
+  int width;
+
+  if (tabify_output)
+    {
+      state_bak = state;
+      mbc[mbc_pos++] = c;
+      mblength = mbrtowc (&wc, mbc, mbc_pos, &state);
+
+      while (mbc_pos > 0)
+        {
+          switch (mblength)
+            {
+            case (size_t)-2:
+              state = state_bak;
+              return;
+
+            case (size_t)-1:
+              state = state_bak;
+              ++output_position;
+              putchar (mbc[0]);
+              memmove (mbc, mbc + 1, MB_CUR_MAX - 1);
+              --mbc_pos;
+              break;
+
+            case 0:
+              mblength = 1;
+
+            default:
+              if (wc == L' ')
+                {
+                  memmove (mbc, mbc + mblength, MB_CUR_MAX - mblength);
+                  --mbc_pos;
+                  ++spaces_not_printed;
+                  return;
+                }
+              else if (spaces_not_printed > 0)
+                print_white_space ();
+
+              /* Nonprintables are assumed to have width 0, except L'\b'. */
+              if ((width = wcwidth (wc)) < 1)
+                {
+                  if (wc == L'\b')
+                    --output_position;
+                }
+              else
+                output_position += width;
+
+              fwrite (mbc, sizeof(char), mblength, stdout);
+              memmove (mbc, mbc + mblength, MB_CUR_MAX - mblength);
+              mbc_pos -= mblength;
+            }
+        }
+      return;
+    }
+  putchar (c);
+}
+#endif
+
 /* Skip to page PAGE before printing.
    PAGE may be larger than total number of pages. */
 
@@ -2508,9 +2714,9 @@
           align_empty_cols = false;
         }
 
-      if (padding_not_printed - col_sep_length > 0)
+      if (padding_not_printed - col_sep_width > 0)
         {
-          pad_across_to (padding_not_printed - col_sep_length);
+          pad_across_to (padding_not_printed - col_sep_width);
           padding_not_printed = ANYWHERE;
         }
 
@@ -2611,9 +2817,9 @@
         }
     }
 
-  if (padding_not_printed - col_sep_length > 0)
+  if (padding_not_printed - col_sep_width > 0)
     {
-      pad_across_to (padding_not_printed - col_sep_length);
+      pad_across_to (padding_not_printed - col_sep_width);
       padding_not_printed = ANYWHERE;
     }
 
@@ -2626,8 +2832,8 @@
   if (spaces_not_printed == 0)
     {
       output_position = p->start_position + end_vector[line];
-      if (p->start_position - col_sep_length == chars_per_margin)
-        output_position -= col_sep_length;
+      if (p->start_position - col_sep_width == chars_per_margin)
+        output_position -= col_sep_width;
     }
 
   return true;
@@ -2646,7 +2852,7 @@
    number of characters is 1.) */
 
 static int
-char_to_clump (char c)
+char_to_clump_single (char c)
 {
   unsigned char uc = c;
   char *s = clump_buff;
@@ -2656,10 +2862,10 @@
   int chars;
   int chars_per_c = 8;
 
-  if (c == input_tab_char)
+  if (c == input_tab_char[0])
     chars_per_c = chars_per_input_tab;
 
-  if (c == input_tab_char || c == '\t')
+  if (c == input_tab_char[0] || c == '\t')
     {
       width = TAB_WIDTH (chars_per_c, input_position);
 
@@ -2740,6 +2946,154 @@
   return chars;
 }
 
+#ifdef HAVE_MBRTOWC
+static int
+char_to_clump_multi (char c)
+{
+  static size_t mbc_pos = 0;
+  static char mbc[MB_LEN_MAX] = {'\0'};
+  static mbstate_t state = {'\0'};
+  mbstate_t state_bak;
+  wchar_t wc;
+  size_t mblength;
+  int wc_width;
+  register char *s = clump_buff;
+  register int i, j;
+  char esc_buff[4];
+  int width;
+  int chars;
+  int chars_per_c = 8;
+
+  state_bak = state;
+  mbc[mbc_pos++] = c;
+  mblength = mbrtowc (&wc, mbc, mbc_pos, &state);
+
+  width = 0;
+  chars = 0;
+  while (mbc_pos > 0)
+    {
+      switch (mblength)
+        {
+        case (size_t)-2:
+          state = state_bak;
+          return 0;
+
+        case (size_t)-1:
+          state = state_bak;
+          mblength = 1;
+
+          if (use_esc_sequence || use_cntrl_prefix)
+            {
+              width = +4;
+              chars = +4;
+              *s++ = '\\';
+              sprintf (esc_buff, "%03o", (unsigned char) mbc[0]);
+              for (i = 0; i <= 2; ++i)
+                *s++ = (int) esc_buff[i];
+            }
+          else
+            {
+              width += 1;
+              chars += 1;
+              *s++ = mbc[0];
+            }
+          break;
+
+        case 0:
+          mblength = 1;
+                /* Fall through */
+
+        default:
+          if (memcmp (mbc, input_tab_char, mblength) == 0)
+            chars_per_c = chars_per_input_tab;
+
+          if (memcmp (mbc, input_tab_char, mblength) == 0 || c == '\t')
+            {
+              int  width_inc;
+
+              width_inc = TAB_WIDTH (chars_per_c, input_position);
+              width += width_inc;
+
+              if (untabify_input)
+                {
+                  for (i = width_inc; i; --i)
+                    *s++ = ' ';
+                  chars += width_inc;
+                }
+              else
+                {
+                  for (i = 0; i <  mblength; i++)
+                    *s++ = mbc[i];
+                  chars += mblength;
+                }
+            }
+          else if ((wc_width = wcwidth (wc)) < 1)
+            {
+              if (use_esc_sequence)
+                {
+                  for (i = 0; i < mblength; i++)
+                    {
+                      width += 4;
+                      chars += 4;
+                      *s++ = '\\';
+                      sprintf (esc_buff, "%03o", (unsigned char) mbc[i]);
+                      for (j = 0; j <= 2; ++j)
+                        *s++ = (int) esc_buff[j];
+                    }
+                }
+              else if (use_cntrl_prefix)
+                {
+                  if (wc < 0200)
+                    {
+                      width += 2;
+                      chars += 2;
+                      *s++ = '^';
+                      *s++ = wc ^ 0100;
+                    }
+                  else
+                    {
+                      for (i = 0; i < mblength; i++)
+                        {
+                          width += 4;
+                          chars += 4;
+                          *s++ = '\\';
+                          sprintf (esc_buff, "%03o", (unsigned char) mbc[i]);
+                          for (j = 0; j <= 2; ++j)
+                            *s++ = (int) esc_buff[j];
+                        }
+                    }
+                }
+              else if (wc == L'\b')
+                {
+                  width += -1;
+                  chars += 1;
+                  *s++ = c;
+                }
+              else
+                {
+                  width += 0;
+                  chars += mblength;
+                  for (i = 0; i < mblength; i++)
+                    *s++ = mbc[i];
+                }
+            }
+          else
+            {
+              width += wc_width;
+              chars += mblength;
+              for (i = 0; i < mblength; i++)
+                *s++ = mbc[i];
+            }
+        }
+      memmove (mbc, mbc + mblength, MB_CUR_MAX - mblength);
+      mbc_pos -= mblength;
+    }
+
+  input_position += width;
+  return chars;
+}
+#endif
+
 /* We've just printed some files and need to clean up things before
    looking for more options and printing the next batch of files.
 
diff -Naur coreutils-8.19.orig/src/sort.c coreutils-8.19/src/sort.c
--- coreutils-8.19.orig/src/sort.c	2012-08-18 00:39:29.000000000 -0500
+++ coreutils-8.19/src/sort.c	2012-08-20 21:50:40.000000000 -0500
@@ -29,6 +29,15 @@
 #include <sys/wait.h>
 #include <signal.h>
 #include <assert.h>
+
+#if HAVE_WCHAR_H
+# include <wchar.h>
+#endif
+/* Get isw* functions. */
+#if HAVE_WCTYPE_H
+# include <wctype.h>
+#endif
+
 #include "system.h"
 #include "argmatch.h"
 #include "error.h"
@@ -166,12 +175,34 @@
 
 /* Nonzero if the corresponding locales are hard.  */
 static bool hard_LC_COLLATE;
-#if HAVE_NL_LANGINFO
+#if HAVE_LANGINFO_CODESET
 static bool hard_LC_TIME;
 #endif
 
 #define NONZERO(x) ((x) != 0)
 
+/* get a multibyte character's byte length. */
+#define GET_BYTELEN_OF_CHAR(LIM, PTR, MBLENGTH, STATE)                        \
+  do                                                                        \
+    {                                                                        \
+      wchar_t wc;                                                        \
+      mbstate_t state_bak;                                                \
+                                                                        \
+      state_bak = STATE;                                                \
+      mblength = mbrtowc (&wc, PTR, LIM - PTR, &STATE);                        \
+                                                                        \
+      switch (MBLENGTH)                                                        \
+        {                                                                \
+        case (size_t)-1:                                                \
+        case (size_t)-2:                                                \
+          STATE = state_bak;                                                \
+                /* Fall through. */                                        \
+        case 0:                                                                \
+          MBLENGTH = 1;                                                        \
+      }                                                                        \
+    }                                                                        \
+  while (0)
+
 /* The kind of blanks for '-b' to skip in various options. */
 enum blanktype { bl_start, bl_end, bl_both };
 
@@ -345,13 +376,11 @@
    they were read if all keys compare equal.  */
 static bool stable;
 
-/* If TAB has this value, blanks separate fields.  */
-enum { TAB_DEFAULT = CHAR_MAX + 1 };
-
-/* Tab character separating fields.  If TAB_DEFAULT, then fields are
+/* Tab character separating fields.  If tab_length is 0, then fields are
    separated by the empty string between a non-blank character and a blank
    character. */
-static int tab = TAB_DEFAULT;
+static char tab[MB_LEN_MAX + 1];
+static size_t tab_length = 0;
 
 /* Flag to remove consecutive duplicate lines from the output.
    Only the last of a sequence of equal lines will be output. */
@@ -784,6 +813,46 @@
     reap (-1);
 }
 
+/* Function pointers. */
+static void
+(*inittables) (void);
+static char *
+(*begfield) (const struct line*, const struct keyfield *);
+static char *
+(*limfield) (const struct line*, const struct keyfield *);
+static void
+(*skipblanks) (char **ptr, char *lim);
+static int
+(*getmonth) (char const *, size_t, char **);
+static int
+(*keycompare) (const struct line *, const struct line *);
+static int
+(*numcompare) (const char *, const char *);
+
+/* Test for white space multibyte character.
+   Set LENGTH the byte length of investigated multibyte character. */
+#if HAVE_MBRTOWC
+static int
+ismbblank (const char *str, size_t len, size_t *length)
+{
+  size_t mblength;
+  wchar_t wc;
+  mbstate_t state;
+
+  memset (&state, '\0', sizeof(mbstate_t));
+  mblength = mbrtowc (&wc, str, len, &state);
+
+  if (mblength == (size_t)-1 || mblength == (size_t)-2)
+    {
+      *length = 1;
+      return 0;
+    }
+
+  *length = (mblength < 1) ? 1 : mblength;
+  return iswblank (wc);
+}
+#endif
+
 /* Clean up any remaining temporary files.  */
 
 static void
@@ -1224,7 +1293,7 @@
   free (node);
 }
 
-#if HAVE_NL_LANGINFO
+#if HAVE_LANGINFO_CODESET
 
 static int
 struct_month_cmp (void const *m1, void const *m2)
@@ -1239,7 +1308,7 @@
 /* Initialize the character class tables. */
 
 static void
-inittables (void)
+inittables_uni (void)
 {
   size_t i;
 
@@ -1251,7 +1320,7 @@
       fold_toupper[i] = toupper (i);
     }
 
-#if HAVE_NL_LANGINFO
+#if HAVE_LANGINFO_CODESET
   /* If we're not in the "C" locale, read different names for months.  */
   if (hard_LC_TIME)
     {
@@ -1333,6 +1402,84 @@
     xstrtol_fatal (e, oi, c, long_options, s);
 }
 
+#if HAVE_MBRTOWC
+static void
+inittables_mb (void)
+{
+  int i, j, k, l;
+  char *name, *s, *lc_time, *lc_ctype;
+  size_t s_len, mblength;
+  char mbc[MB_LEN_MAX];
+  wchar_t wc, pwc;
+  mbstate_t state_mb, state_wc;
+
+  lc_time = setlocale (LC_TIME, "");
+  if (lc_time)
+    lc_time = xstrdup (lc_time);
+
+  lc_ctype = setlocale (LC_CTYPE, "");
+  if (lc_ctype)
+    lc_ctype = xstrdup (lc_ctype);
+
+  if (lc_time && lc_ctype)
+    /* temporarily set LC_CTYPE to match LC_TIME, so that we can convert
+     * the names of months to upper case */
+    setlocale (LC_CTYPE, lc_time);
+
+  for (i = 0; i < MONTHS_PER_YEAR; i++)
+    {
+      s = (char *) nl_langinfo (ABMON_1 + i);
+      s_len = strlen (s);
+      monthtab[i].name = name = (char *) xmalloc (s_len + 1);
+      monthtab[i].val = i + 1;
+
+      memset (&state_mb, '\0', sizeof (mbstate_t));
+      memset (&state_wc, '\0', sizeof (mbstate_t));
+
+      for (j = 0; j < s_len;)
+        {
+          if (!ismbblank (s + j, s_len - j, &mblength))
+            break;
+          j += mblength;
+        }
+
+      for (k = 0; j < s_len;)
+        {
+          mblength = mbrtowc (&wc, (s + j), (s_len - j), &state_mb);
+          assert (mblength != (size_t)-1 && mblength != (size_t)-2);
+          if (mblength == 0)
+            break;
+
+          pwc = towupper (wc);
+          if (pwc == wc)
+            {
+              memcpy (mbc, s + j, mblength);
+              j += mblength;
+            }
+          else
+            {
+              j += mblength;
+              mblength = wcrtomb (mbc, pwc, &state_wc);
+              assert (mblength != (size_t)0 && mblength != (size_t)-1);
+            }
+
+          for (l = 0; l < mblength; l++)
+            name[k++] = mbc[l];
+        }
+      name[k] = '\0';
+    }
+  qsort ((void *) monthtab, MONTHS_PER_YEAR,
+      sizeof (struct month), struct_month_cmp);
+
+  if (lc_time && lc_ctype)
+    /* restore the original locales */
+    setlocale (LC_CTYPE, lc_ctype);
+
+  free (lc_ctype);
+  free (lc_time);
+}
+#endif
+
 /* Specify the amount of main memory to use when sorting.  */
 static void
 specify_sort_size (int oi, char c, char const *s)
@@ -1565,7 +1712,7 @@
    by KEY in LINE. */
 
 static char *
-begfield (struct line const *line, struct keyfield const *key)
+begfield_uni (const struct line *line, const struct keyfield *key)
 {
   char *ptr = line->text, *lim = ptr + line->length - 1;
   size_t sword = key->sword;
@@ -1574,10 +1721,10 @@
   /* The leading field separator itself is included in a field when -t
      is absent.  */
 
-  if (tab != TAB_DEFAULT)
+  if (tab_length)
     while (ptr < lim && sword--)
       {
-        while (ptr < lim && *ptr != tab)
+        while (ptr < lim && *ptr != tab[0])
           ++ptr;
         if (ptr < lim)
           ++ptr;
@@ -1603,11 +1750,70 @@
   return ptr;
 }
 
+#if HAVE_MBRTOWC
+static char *
+begfield_mb (const struct line *line, const struct keyfield *key)
+{
+  int i;
+  char *ptr = line->text, *lim = ptr + line->length - 1;
+  size_t sword = key->sword;
+  size_t schar = key->schar;
+  size_t mblength;
+  mbstate_t state;
+
+  memset (&state, '\0', sizeof(mbstate_t));
+
+  if (tab_length)
+    while (ptr < lim && sword--)
+      {
+        while (ptr < lim && memcmp (ptr, tab, tab_length) != 0)
+          {
+            GET_BYTELEN_OF_CHAR (lim, ptr, mblength, state);
+            ptr += mblength;
+          }
+        if (ptr < lim)
+          {
+            GET_BYTELEN_OF_CHAR (lim, ptr, mblength, state);
+            ptr += mblength;
+          }
+      }
+  else
+    while (ptr < lim && sword--)
+      {
+        while (ptr < lim && ismbblank (ptr, lim - ptr, &mblength))
+          ptr += mblength;
+        if (ptr < lim)
+          {
+            GET_BYTELEN_OF_CHAR (lim, ptr, mblength, state);
+            ptr += mblength;
+          }
+        while (ptr < lim && !ismbblank (ptr, lim - ptr, &mblength))
+          ptr += mblength;
+      }
+
+  if (key->skipsblanks)
+    while (ptr < lim && ismbblank (ptr, lim - ptr, &mblength))
+      ptr += mblength;
+
+  for (i = 0; i < schar; i++)
+    {
+      GET_BYTELEN_OF_CHAR (lim, ptr, mblength, state);
+
+      if (ptr + mblength > lim)
+        break;
+      else
+        ptr += mblength;
+    }
+
+  return ptr;
+}
+#endif
+
 /* Return the limit of (a pointer to the first character after) the field
    in LINE specified by KEY. */
 
 static char *
-limfield (struct line const *line, struct keyfield const *key)
+limfield_uni (const struct line *line, const struct keyfield *key)
 {
   char *ptr = line->text, *lim = ptr + line->length - 1;
   size_t eword = key->eword, echar = key->echar;
@@ -1622,10 +1828,10 @@
      'beginning' is the first character following the delimiting TAB.
      Otherwise, leave PTR pointing at the first 'blank' character after
      the preceding field.  */
-  if (tab != TAB_DEFAULT)
+  if (tab_length)
     while (ptr < lim && eword--)
       {
-        while (ptr < lim && *ptr != tab)
+        while (ptr < lim && *ptr != tab[0])
           ++ptr;
         if (ptr < lim && (eword || echar))
           ++ptr;
@@ -1671,10 +1877,10 @@
      */
 
   /* Make LIM point to the end of (one byte past) the current field.  */
-  if (tab != TAB_DEFAULT)
+  if (tab_length)
     {
       char *newlim;
-      newlim = memchr (ptr, tab, lim - ptr);
+      newlim = memchr (ptr, tab[0], lim - ptr);
       if (newlim)
         lim = newlim;
     }
@@ -1705,6 +1911,130 @@
   return ptr;
 }
 
+#if HAVE_MBRTOWC
+static char *
+limfield_mb (const struct line *line, const struct keyfield *key)
+{
+  char *ptr = line->text, *lim = ptr + line->length - 1;
+  size_t eword = key->eword, echar = key->echar;
+  int i;
+  size_t mblength;
+  mbstate_t state;
+
+  if (echar == 0)
+    eword++; /* skip all of end field. */
+
+  memset (&state, '\0', sizeof(mbstate_t));
+
+  if (tab_length)
+    while (ptr < lim && eword--)
+      {
+        while (ptr < lim && memcmp (ptr, tab, tab_length) != 0)
+          {
+            GET_BYTELEN_OF_CHAR (lim, ptr, mblength, state);
+            ptr += mblength;
+          }
+        if (ptr < lim && (eword | echar))
+          {
+            GET_BYTELEN_OF_CHAR (lim, ptr, mblength, state);
+            ptr += mblength;
+          }
+      }
+  else
+    while (ptr < lim && eword--)
+      {
+        while (ptr < lim && ismbblank (ptr, lim - ptr, &mblength))
+          ptr += mblength;
+        if (ptr < lim)
+          {
+            GET_BYTELEN_OF_CHAR (lim, ptr, mblength, state);
+            ptr += mblength;
+          }
+        while (ptr < lim && !ismbblank (ptr, lim - ptr, &mblength))
+          ptr += mblength;
+      }
+
+
+# ifdef POSIX_UNSPECIFIED
+  /* Make LIM point to the end of (one byte past) the current field.  */
+  if (tab_length)
+    {
+      char *newlim, *p;
+
+      newlim = NULL;
+      for (p = ptr; p < lim;)
+         {
+          if (memcmp (p, tab, tab_length) == 0)
+            {
+              newlim = p;
+              break;
+            }
+
+          GET_BYTELEN_OF_CHAR (lim, ptr, mblength, state);
+          p += mblength;
+        }
+    }
+  else
+    {
+      char *newlim;
+      newlim = ptr;
+
+      while (newlim < lim && ismbblank (newlim, lim - newlim, &mblength))
+        newlim += mblength;
+      if (ptr < lim)
+        {
+          GET_BYTELEN_OF_CHAR (lim, ptr, mblength, state);
+          ptr += mblength;
+        }
+      while (newlim < lim && !ismbblank (newlim, lim - newlim, &mblength))
+        newlim += mblength;
+      lim = newlim;
+    }
+# endif
+
+  if (echar != 0)
+  {
+    /* If we're skipping leading blanks, don't start counting characters
+     *      until after skipping past any leading blanks.  */
+    if (key->skipsblanks)
+      while (ptr < lim && ismbblank (ptr, lim - ptr, &mblength))
+        ptr += mblength;
+
+    memset (&state, '\0', sizeof(mbstate_t));
+
+    /* Advance PTR by ECHAR (if possible), but no further than LIM.  */
+    for (i = 0; i < echar; i++)
+     {
+        GET_BYTELEN_OF_CHAR (lim, ptr, mblength, state);
+
+        if (ptr + mblength > lim)
+          break;
+        else
+          ptr += mblength;
+      }
+  }
+
+  return ptr;
+}
+#endif
+
+static void
+skipblanks_uni (char **ptr, char *lim)
+{
+  while (*ptr < lim && blanks[to_uchar (**ptr)])
+    ++(*ptr);
+}
+
+#if HAVE_MBRTOWC
+static void
+skipblanks_mb (char **ptr, char *lim)
+{
+  size_t mblength;
+  while (*ptr < lim && ismbblank (*ptr, lim - *ptr, &mblength))
+    (*ptr) += mblength;
+}
+#endif
+
 /* Fill BUF reading from FP, moving buf->left bytes from the end
    of buf->buf to the beginning first.  If EOF is reached and the
    file wasn't terminated by a newline, supply one.  Set up BUF's line
@@ -1791,8 +2121,22 @@
                   else
                     {
                       if (key->skipsblanks)
-                        while (blanks[to_uchar (*line_start)])
-                          line_start++;
+                        {
+#if HAVE_MBRTOWC
+                          if (MB_CUR_MAX > 1)
+                            {
+                              size_t mblength;
+                              while (line_start < line->keylim &&
+                                     ismbblank (line_start,
+                                                line->keylim - line_start,
+                                                &mblength))
+                                line_start += mblength;
+                            }
+                          else
+#endif
+                          while (blanks[to_uchar (*line_start)])
+                            line_start++;
+                        }
                       line->keybeg = line_start;
                     }
                 }
@@ -1913,7 +2257,7 @@
    hideously fast. */
 
 static int
-numcompare (char const *a, char const *b)
+numcompare_uni (const char *a, const char *b)
 {
   while (blanks[to_uchar (*a)])
     a++;
@@ -1923,6 +2267,25 @@
   return strnumcmp (a, b, decimal_point, thousands_sep);
 }
 
+#if HAVE_MBRTOWC
+static int
+numcompare_mb (const char *a, const char *b)
+{
+  size_t mblength, len;
+  len = strlen (a); /* okay for UTF-8 */
+  while (*a && ismbblank (a, len > MB_CUR_MAX ? MB_CUR_MAX : len, &mblength))
+    {
+      a += mblength;
+      len -= mblength;
+    }
+  len = strlen (b); /* okay for UTF-8 */
+  while (*b && ismbblank (b, len > MB_CUR_MAX ? MB_CUR_MAX : len, &mblength))
+    b += mblength;
+
+  return strnumcmp (a, b, decimal_point, thousands_sep);
+}
+#endif /* HAV_EMBRTOWC */
+
 /* Work around a problem whereby the long double value returned by glibc's
    strtold ("NaN", ...) contains uninitialized bits: clear all bytes of
    A and B before calling strtold.  FIXME: remove this function once
@@ -1973,7 +2336,7 @@
    Return 0 if the name in S is not recognized.  */
 
 static int
-getmonth (char const *month, char **ea)
+getmonth_uni (char const *month, size_t len, char **ea)
 {
   size_t lo = 0;
   size_t hi = MONTHS_PER_YEAR;
@@ -2248,15 +2611,14 @@
           char saved = *lim;
           *lim = '\0';
 
-          while (blanks[to_uchar (*beg)])
-            beg++;
+          skipblanks (&beg, lim);
 
           char *tighter_lim = beg;
 
           if (lim < beg)
             tighter_lim = lim;
           else if (key->month)
-            getmonth (beg, &tighter_lim);
+            getmonth (beg, lim-beg, &tighter_lim);
           else if (key->general_numeric)
             ignore_value (strtold (beg, &tighter_lim));
           else if (key->numeric || key->human_numeric)
@@ -2400,7 +2762,7 @@
       bool maybe_space_aligned = !hard_LC_COLLATE && default_key_compare (key)
                                  && !(key->schar || key->echar);
       bool line_offset = key->eword == 0 && key->echar != 0; /* -k1.x,1.y  */
-      if (!gkey_only && tab == TAB_DEFAULT && !line_offset
+      if (!gkey_only && !tab_length && !line_offset
           && ((!key->skipsblanks && !(implicit_skip || maybe_space_aligned))
               || (!key->skipsblanks && key->schar)
               || (!key->skipeblanks && key->echar)))
@@ -2458,11 +2820,83 @@
     error (0, 0, _("option '-r' only applies to last-resort comparison"));
 }
 
+#if HAVE_MBRTOWC
+static int
+getmonth_mb (const char *s, size_t len, char **ea)
+{
+  char *month;
+  register size_t i;
+  register int lo = 0, hi = MONTHS_PER_YEAR, result;
+  char *tmp;
+  size_t wclength, mblength;
+  const char **pp;
+  const wchar_t **wpp;
+  wchar_t *month_wcs;
+  mbstate_t state;
+
+  while (len > 0 && ismbblank (s, len, &mblength))
+    {
+      s += mblength;
+      len -= mblength;
+    }
+
+  if (len == 0)
+    return 0;
+
+  month = (char *) alloca (len + 1);
+
+  tmp = (char *) alloca (len + 1);
+  memcpy (tmp, s, len);
+  tmp[len] = '\0';
+  pp = (const char **)&tmp;
+  month_wcs = (wchar_t *) alloca ((len + 1) * sizeof (wchar_t));
+  memset (&state, '\0', sizeof(mbstate_t));
+
+  wclength = mbsrtowcs (month_wcs, pp, len + 1, &state);
+  if (wclength == (size_t)-1 || *pp != NULL)
+    error (SORT_FAILURE, 0, _("Invalid multibyte input %s."), quote(s));
+
+  for (i = 0; i < wclength; i++)
+    {
+      month_wcs[i] = towupper(month_wcs[i]);
+      if (iswblank (month_wcs[i]))
+        {
+          month_wcs[i] = L'\0';
+          break;
+        }
+    }
+
+  wpp = (const wchar_t **)&month_wcs;
+
+  mblength = wcsrtombs (month, wpp, len + 1, &state);
+  assert (mblength != (-1) && *wpp == NULL);
+
+  do
+    {
+      int ix = (lo + hi) / 2;
+
+      if (strncmp (month, monthtab[ix].name, strlen (monthtab[ix].name)) < 0)
+        hi = ix;
+      else
+        lo = ix;
+    }
+  while (hi - lo > 1);
+
+  result = (!strncmp (month, monthtab[lo].name, strlen (monthtab[lo].name))
+      ? monthtab[lo].val : 0);
+
+  if (ea && result)
+     *ea = s + strlen (monthtab[lo].name);
+
+  return result;
+}
+#endif
+
 /* Compare two lines A and B trying every key in sequence until there
    are no more keys or a difference is found. */
 
 static int
-keycompare (struct line const *a, struct line const *b)
+keycompare_uni (const struct line *a, const struct line *b)
 {
   struct keyfield *key = keylist;
 
@@ -2547,7 +2981,7 @@
           else if (key->human_numeric)
             diff = human_numcompare (ta, tb);
           else if (key->month)
-            diff = getmonth (ta, NULL) - getmonth (tb, NULL);
+            diff = getmonth (ta, tlena, NULL) - getmonth (tb, tlenb, NULL);
           else if (key->random)
             diff = compare_random (ta, tlena, tb, tlenb);
           else if (key->version)
@@ -2663,6 +3097,180 @@
   return key->reverse ? -diff : diff;
 }
 
+#if HAVE_MBRTOWC
+static int
+keycompare_mb (const struct line *a, const struct line *b)
+{
+  struct keyfield *key = keylist;
+
+  /* For the first iteration only, the key positions have been
+     precomputed for us. */
+  char *texta = a->keybeg;
+  char *textb = b->keybeg;
+  char *lima = a->keylim;
+  char *limb = b->keylim;
+
+  size_t mblength_a, mblength_b;
+  wchar_t wc_a, wc_b;
+  mbstate_t state_a, state_b;
+
+  int diff;
+
+  memset (&state_a, '\0', sizeof(mbstate_t));
+  memset (&state_b, '\0', sizeof(mbstate_t));
+
+  for (;;)
+    {
+      char const *translate = key->translate;
+      bool const *ignore = key->ignore;
+
+      /* Find the lengths. */
+      size_t lena = lima <= texta ? 0 : lima - texta;
+      size_t lenb = limb <= textb ? 0 : limb - textb;
+
+      /* Actually compare the fields. */
+      if (key->random)
+        diff = compare_random (texta, lena, textb, lenb);
+      else if (key->numeric | key->general_numeric | key->human_numeric)
+        {
+          char savea = *lima, saveb = *limb;
+
+          *lima = *limb = '\0';
+          diff = (key->numeric ? numcompare (texta, textb)
+                  : key->general_numeric ? general_numcompare (texta, textb)
+                  : human_numcompare (texta, textb));
+          *lima = savea, *limb = saveb;
+        }
+      else if (key->version)
+        diff = filevercmp (texta, textb);
+      else if (key->month)
+        diff = getmonth (texta, lena, NULL) - getmonth (textb, lenb, NULL);
+      else
+        {
+          if (ignore || translate)
+            {
+              char *copy_a = (char *) alloca (lena + 1 + lenb + 1);
+              char *copy_b = copy_a + lena + 1;
+              size_t new_len_a, new_len_b;
+              size_t i, j;
+
+              /* Ignore and/or translate chars before comparing.  */
+# define IGNORE_CHARS(NEW_LEN, LEN, TEXT, COPY, WC, MBLENGTH, STATE)        \
+  do                                                                        \
+    {                                                                        \
+      wchar_t uwc;                                                        \
+      char mbc[MB_LEN_MAX];                                                \
+      mbstate_t state_wc;                                                \
+                                                                        \
+      for (NEW_LEN = i = 0; i < LEN;)                                        \
+        {                                                                \
+          mbstate_t state_bak;                                                \
+                                                                        \
+          state_bak = STATE;                                                \
+          MBLENGTH = mbrtowc (&WC, TEXT + i, LEN - i, &STATE);                \
+                                                                        \
+          if (MBLENGTH == (size_t)-2 || MBLENGTH == (size_t)-1                \
+              || MBLENGTH == 0)                                                \
+            {                                                                \
+              if (MBLENGTH == (size_t)-2 || MBLENGTH == (size_t)-1)        \
+                STATE = state_bak;                                        \
+              if (!ignore)                                                \
+                COPY[NEW_LEN++] = TEXT[i];                                \
+              i++;                                                         \
+              continue;                                                        \
+            }                                                                \
+                                                                        \
+          if (ignore)                                                        \
+            {                                                                \
+              if ((ignore == nonprinting && !iswprint (WC))                \
+                   || (ignore == nondictionary                                \
+                       && !iswalnum (WC) && !iswblank (WC)))                \
+                {                                                        \
+                  i += MBLENGTH;                                        \
+                  continue;                                                \
+                }                                                        \
+            }                                                                \
+                                                                        \
+          if (translate)                                                \
+            {                                                                \
+                                                                        \
+              uwc = towupper(WC);                                        \
+              if (WC == uwc)                                                \
+                {                                                        \
+                  memcpy (mbc, TEXT + i, MBLENGTH);                        \
+                  i += MBLENGTH;                                        \
+                }                                                        \
+              else                                                        \
+                {                                                        \
+                  i += MBLENGTH;                                        \
+                  WC = uwc;                                                \
+                  memset (&state_wc, '\0', sizeof (mbstate_t));                \
+                                                                        \
+                  MBLENGTH = wcrtomb (mbc, WC, &state_wc);                \
+                  assert (MBLENGTH != (size_t)-1 && MBLENGTH != 0);        \
+                }                                                        \
+                                                                        \
+              for (j = 0; j < MBLENGTH; j++)                                \
+                COPY[NEW_LEN++] = mbc[j];                                \
+            }                                                                \
+          else                                                                \
+            for (j = 0; j < MBLENGTH; j++)                                \
+              COPY[NEW_LEN++] = TEXT[i++];                                \
+        }                                                                \
+      COPY[NEW_LEN] = '\0';                                                \
+    }                                                                        \
+  while (0)
+              IGNORE_CHARS (new_len_a, lena, texta, copy_a,
+                            wc_a, mblength_a, state_a);
+              IGNORE_CHARS (new_len_b, lenb, textb, copy_b,
+                            wc_b, mblength_b, state_b);
+              diff = xmemcoll (copy_a, new_len_a, copy_b, new_len_b);
+            }
+          else if (lena == 0)
+            diff = - NONZERO (lenb);
+          else if (lenb == 0)
+            goto greater;
+          else
+            diff = xmemcoll (texta, lena, textb, lenb);
+        }
+
+      if (diff)
+        goto not_equal;
+
+      key = key->next;
+      if (! key)
+        break;
+
+      /* Find the beginning and limit of the next field.  */
+      if (key->eword != -1)
+        lima = limfield (a, key), limb = limfield (b, key);
+      else
+        lima = a->text + a->length - 1, limb = b->text + b->length - 1;
+
+      if (key->sword != -1)
+        texta = begfield (a, key), textb = begfield (b, key);
+      else
+        {
+          texta = a->text, textb = b->text;
+          if (key->skipsblanks)
+            {
+              while (texta < lima && ismbblank (texta, lima - texta, &mblength_a))
+                texta += mblength_a;
+              while (textb < limb && ismbblank (textb, limb - textb, &mblength_b))
+                textb += mblength_b;
+            }
+        }
+    }
+
+  return 0;
+
+greater:
+  diff = 1;
+not_equal:
+  return key->reverse ? -diff : diff;
+}
+#endif
+
 /* Compare two lines A and B, returning negative, zero, or positive
    depending on whether A compares less than, equal to, or greater than B. */
 
@@ -4158,7 +4766,7 @@
   initialize_exit_failure (SORT_FAILURE);
 
   hard_LC_COLLATE = hard_locale (LC_COLLATE);
-#if HAVE_NL_LANGINFO
+#if HAVE_LANGINFO_CODESET
   hard_LC_TIME = hard_locale (LC_TIME);
 #endif
 
@@ -4179,6 +4787,29 @@
       thousands_sep = -1;
   }
 
+#if HAVE_MBRTOWC
+  if (MB_CUR_MAX > 1)
+    {
+      inittables = inittables_mb;
+      begfield = begfield_mb;
+      limfield = limfield_mb;
+      skipblanks = skipblanks_mb;
+      getmonth = getmonth_mb;
+      keycompare = keycompare_mb;
+      numcompare = numcompare_mb;
+    }
+  else
+#endif
+    {
+      inittables = inittables_uni;
+      begfield = begfield_uni;
+      limfield = limfield_uni;
+      skipblanks = skipblanks_uni;
+      getmonth = getmonth_uni;
+      keycompare = keycompare_uni;
+      numcompare = numcompare_uni;
+    }
+
   have_read_stdin = false;
   inittables ();
 
@@ -4453,13 +5084,34 @@
 
         case 't':
           {
-            char newtab = optarg[0];
-            if (! newtab)
+            char newtab[MB_LEN_MAX + 1];
+            size_t newtab_length = 1;
+            strncpy (newtab, optarg, MB_LEN_MAX);
+            if (! newtab[0])
               error (SORT_FAILURE, 0, _("empty tab"));
-            if (optarg[1])
+#if HAVE_MBRTOWC
+            if (MB_CUR_MAX > 1)
+              {
+                wchar_t wc;
+                mbstate_t state;
+
+                memset (&state, '\0', sizeof (mbstate_t));
+                newtab_length = mbrtowc (&wc, newtab, strnlen (newtab,
+                                                               MB_LEN_MAX),
+                                         &state);
+                switch (newtab_length)
+                  {
+                  case (size_t) -1:
+                  case (size_t) -2:
+                  case 0:
+                    newtab_length = 1;
+                  }
+              }
+#endif
+            if (newtab_length == 1 && optarg[1])
               {
                 if (STREQ (optarg, "\\0"))
-                  newtab = '\0';
+                  newtab[0] = '\0';
                 else
                   {
                     /* Provoke with 'sort -txx'.  Complain about
@@ -4470,9 +5122,12 @@
                            quote (optarg));
                   }
               }
-            if (tab != TAB_DEFAULT && tab != newtab)
+            if (tab_length
+                && (tab_length != newtab_length
+                    || memcmp (tab, newtab, tab_length) != 0))
               error (SORT_FAILURE, 0, _("incompatible tabs"));
-            tab = newtab;
+            memcpy (tab, newtab, newtab_length);
+            tab_length = newtab_length;
           }
           break;
 
diff -Naur coreutils-8.19.orig/src/sort.c.orig coreutils-8.19/src/sort.c.orig
--- coreutils-8.19.orig/src/sort.c.orig	1969-12-31 18:00:00.000000000 -0600
+++ coreutils-8.19/src/sort.c.orig	2012-08-20 21:50:40.000000000 -0500
@@ -0,0 +1,4710 @@
+/* sort - sort lines of text (with all kinds of options).
+   Copyright (C) 1988-2012 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+   Written December 1988 by Mike Haertel.
+   The author may be reached (Email) at the address mike@gnu.ai.mit.edu,
+   or (US mail) as Mike Haertel c/o Free Software Foundation.
+
+   Ørn E. Hansen added NLS support in 1997.  */
+
+#include <config.h>
+
+#include <getopt.h>
+#include <pthread.h>
+#include <sys/resource.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <signal.h>
+#include <assert.h>
+#include "system.h"
+#include "argmatch.h"
+#include "error.h"
+#include "fadvise.h"
+#include "filevercmp.h"
+#include "hard-locale.h"
+#include "hash.h"
+#include "heap.h"
+#include "ignore-value.h"
+#include "md5.h"
+#include "mbswidth.h"
+#include "nproc.h"
+#include "physmem.h"
+#include "posixver.h"
+#include "quote.h"
+#include "quotearg.h"
+#include "randread.h"
+#include "readtokens0.h"
+#include "stdio--.h"
+#include "stdlib--.h"
+#include "strnumcmp.h"
+#include "xmemcoll.h"
+#include "xnanosleep.h"
+#include "xstrtol.h"
+
+#ifndef RLIMIT_DATA
+struct rlimit { size_t rlim_cur; };
+# define getrlimit(Resource, Rlp) (-1)
+#endif
+
+/* The official name of this program (e.g., no 'g' prefix).  */
+#define PROGRAM_NAME "sort"
+
+#define AUTHORS \
+  proper_name ("Mike Haertel"), \
+  proper_name ("Paul Eggert")
+
+#if HAVE_LANGINFO_CODESET
+# include <langinfo.h>
+#endif
+
+/* Use SA_NOCLDSTOP as a proxy for whether the sigaction machinery is
+   present.  */
+#ifndef SA_NOCLDSTOP
+# define SA_NOCLDSTOP 0
+/* No sigprocmask.  Always 'return' zero. */
+# define sigprocmask(How, Set, Oset) (0)
+# define sigset_t int
+# if ! HAVE_SIGINTERRUPT
+#  define siginterrupt(sig, flag) /* empty */
+# endif
+#endif
+
+#if !defined OPEN_MAX && defined NR_OPEN
+# define OPEN_MAX NR_OPEN
+#endif
+#if !defined OPEN_MAX
+# define OPEN_MAX 20
+#endif
+
+#define UCHAR_LIM (UCHAR_MAX + 1)
+
+#if HAVE_C99_STRTOLD
+# define long_double long double
+#else
+# define long_double double
+# undef strtold
+# define strtold strtod
+#endif
+
+#ifndef DEFAULT_TMPDIR
+# define DEFAULT_TMPDIR "/tmp"
+#endif
+
+/* Maximum number of lines to merge every time a NODE is taken from
+   the merge queue.  Node is at LEVEL in the binary merge tree,
+   and is responsible for merging TOTAL lines. */
+#define MAX_MERGE(total, level) (((total) >> (2 * ((level) + 1))) + 1)
+
+/* Heuristic value for the number of lines for which it is worth creating
+   a subthread, during an internal merge sort.  I.e., it is a small number
+   of "average" lines for which sorting via two threads is faster than
+   sorting via one on an "average" system.  On a dual-core 2.0 GHz i686
+   system with 3GB of RAM and 2MB of L2 cache, a file containing 128K
+   lines of gensort -a output is sorted slightly faster with --parallel=2
+   than with --parallel=1.  By contrast, using --parallel=1 is about 10%
+   faster than using --parallel=2 with a 64K-line input.  */
+enum { SUBTHREAD_LINES_HEURISTIC = 128 * 1024 };
+verify (4 <= SUBTHREAD_LINES_HEURISTIC);
+
+/* The number of threads after which there are
+   diminishing performance gains.  */
+enum { DEFAULT_MAX_THREADS = 8 };
+
+/* Exit statuses.  */
+enum
+  {
+    /* POSIX says to exit with status 1 if invoked with -c and the
+       input is not properly sorted.  */
+    SORT_OUT_OF_ORDER = 1,
+
+    /* POSIX says any other irregular exit must exit with a status
+       code greater than 1.  */
+    SORT_FAILURE = 2
+  };
+
+enum
+  {
+    /* The number of times we should try to fork a compression process
+       (we retry if the fork call fails).  We don't _need_ to compress
+       temp files, this is just to reduce disk access, so this number
+       can be small.  Each retry doubles in duration.  */
+    MAX_FORK_TRIES_COMPRESS = 4,
+
+    /* The number of times we should try to fork a decompression process.
+       If we can't fork a decompression process, we can't sort, so this
+       number should be big.  Each retry doubles in duration.  */
+    MAX_FORK_TRIES_DECOMPRESS = 9
+  };
+
+enum
+  {
+    /* Level of the end-of-merge node, one level above the root. */
+    MERGE_END = 0,
+
+    /* Level of the root node in merge tree. */
+    MERGE_ROOT = 1
+  };
+
+/* The representation of the decimal point in the current locale.  */
+static int decimal_point;
+
+/* Thousands separator; if -1, then there isn't one.  */
+static int thousands_sep;
+
+/* Nonzero if the corresponding locales are hard.  */
+static bool hard_LC_COLLATE;
+#if HAVE_NL_LANGINFO
+static bool hard_LC_TIME;
+#endif
+
+#define NONZERO(x) ((x) != 0)
+
+/* The kind of blanks for '-b' to skip in various options. */
+enum blanktype { bl_start, bl_end, bl_both };
+
+/* The character marking end of line. Default to \n. */
+static char eolchar = '\n';
+
+/* Lines are held in core as counted strings. */
+struct line
+{
+  char *text;			/* Text of the line. */
+  size_t length;		/* Length including final newline. */
+  char *keybeg;			/* Start of first key. */
+  char *keylim;			/* Limit of first key. */
+};
+
+/* Input buffers. */
+struct buffer
+{
+  char *buf;			/* Dynamically allocated buffer,
+                                   partitioned into 3 regions:
+                                   - input data;
+                                   - unused area;
+                                   - an array of lines, in reverse order.  */
+  size_t used;			/* Number of bytes used for input data.  */
+  size_t nlines;		/* Number of lines in the line array.  */
+  size_t alloc;			/* Number of bytes allocated. */
+  size_t left;			/* Number of bytes left from previous reads. */
+  size_t line_bytes;		/* Number of bytes to reserve for each line. */
+  bool eof;			/* An EOF has been read.  */
+};
+
+/* Sort key.  */
+struct keyfield
+{
+  size_t sword;			/* Zero-origin 'word' to start at. */
+  size_t schar;			/* Additional characters to skip. */
+  size_t eword;			/* Zero-origin last 'word' of key. */
+  size_t echar;			/* Additional characters in field. */
+  bool const *ignore;		/* Boolean array of characters to ignore. */
+  char const *translate;	/* Translation applied to characters. */
+  bool skipsblanks;		/* Skip leading blanks when finding start.  */
+  bool skipeblanks;		/* Skip leading blanks when finding end.  */
+  bool numeric;			/* Flag for numeric comparison.  Handle
+                                   strings of digits with optional decimal
+                                   point, but no exponential notation. */
+  bool random;			/* Sort by random hash of key.  */
+  bool general_numeric;		/* Flag for general, numeric comparison.
+                                   Handle numbers in exponential notation. */
+  bool human_numeric;		/* Flag for sorting by human readable
+                                   units with either SI xor IEC prefixes. */
+  bool month;			/* Flag for comparison by month name. */
+  bool reverse;			/* Reverse the sense of comparison. */
+  bool version;			/* sort by version number */
+  bool obsolete_used;		/* obsolescent key option format is used. */
+  struct keyfield *next;	/* Next keyfield to try. */
+};
+
+struct month
+{
+  char const *name;
+  int val;
+};
+
+/* Binary merge tree node. */
+struct merge_node
+{
+  struct line *lo;              /* Lines to merge from LO child node. */
+  struct line *hi;              /* Lines to merge from HI child ndoe. */
+  struct line *end_lo;          /* End of available lines from LO. */
+  struct line *end_hi;          /* End of available lines from HI. */
+  struct line **dest;           /* Pointer to destination of merge. */
+  size_t nlo;                   /* Total Lines remaining from LO. */
+  size_t nhi;                   /* Total lines remaining from HI. */
+  struct merge_node *parent;    /* Parent node. */
+  struct merge_node *lo_child;  /* LO child node. */
+  struct merge_node *hi_child;  /* HI child node. */
+  unsigned int level;           /* Level in merge tree. */
+  bool queued;                  /* Node is already in heap. */
+  pthread_mutex_t lock;         /* Lock for node operations. */
+};
+
+/* Priority queue of merge nodes. */
+struct merge_node_queue
+{
+  struct heap *priority_queue;  /* Priority queue of merge tree nodes. */
+  pthread_mutex_t mutex;        /* Lock for queue operations. */
+  pthread_cond_t cond;          /* Conditional wait for empty queue to populate
+                                   when popping. */
+};
+
+/* Used to implement --unique (-u).  */
+static struct line saved_line;
+
+/* FIXME: None of these tables work with multibyte character sets.
+   Also, there are many other bugs when handling multibyte characters.
+   One way to fix this is to rewrite 'sort' to use wide characters
+   internally, but doing this with good performance is a bit
+   tricky.  */
+
+/* Table of blanks.  */
+static bool blanks[UCHAR_LIM];
+
+/* Table of non-printing characters. */
+static bool nonprinting[UCHAR_LIM];
+
+/* Table of non-dictionary characters (not letters, digits, or blanks). */
+static bool nondictionary[UCHAR_LIM];
+
+/* Translation table folding lower case to upper.  */
+static char fold_toupper[UCHAR_LIM];
+
+#define MONTHS_PER_YEAR 12
+
+/* Table mapping month names to integers.
+   Alphabetic order allows binary search. */
+static struct month monthtab[] =
+{
+  {"APR", 4},
+  {"AUG", 8},
+  {"DEC", 12},
+  {"FEB", 2},
+  {"JAN", 1},
+  {"JUL", 7},
+  {"JUN", 6},
+  {"MAR", 3},
+  {"MAY", 5},
+  {"NOV", 11},
+  {"OCT", 10},
+  {"SEP", 9}
+};
+
+/* During the merge phase, the number of files to merge at once. */
+#define NMERGE_DEFAULT 16
+
+/* Minimum size for a merge or check buffer.  */
+#define MIN_MERGE_BUFFER_SIZE (2 + sizeof (struct line))
+
+/* Minimum sort size; the code might not work with smaller sizes.  */
+#define MIN_SORT_SIZE (nmerge * MIN_MERGE_BUFFER_SIZE)
+
+/* The number of bytes needed for a merge or check buffer, which can
+   function relatively efficiently even if it holds only one line.  If
+   a longer line is seen, this value is increased.  */
+static size_t merge_buffer_size = MAX (MIN_MERGE_BUFFER_SIZE, 256 * 1024);
+
+/* The approximate maximum number of bytes of main memory to use, as
+   specified by the user.  Zero if the user has not specified a size.  */
+static size_t sort_size;
+
+/* The initial allocation factor for non-regular files.
+   This is used, e.g., when reading from a pipe.
+   Don't make it too big, since it is multiplied by ~130 to
+   obtain the size of the actual buffer sort will allocate.
+   Also, there may be 8 threads all doing this at the same time.  */
+#define INPUT_FILE_SIZE_GUESS (128 * 1024)
+
+/* Array of directory names in which any temporary files are to be created. */
+static char const **temp_dirs;
+
+/* Number of temporary directory names used.  */
+static size_t temp_dir_count;
+
+/* Number of allocated slots in temp_dirs.  */
+static size_t temp_dir_alloc;
+
+/* Flag to reverse the order of all comparisons. */
+static bool reverse;
+
+/* Flag for stable sort.  This turns off the last ditch bytewise
+   comparison of lines, and instead leaves lines in the same order
+   they were read if all keys compare equal.  */
+static bool stable;
+
+/* If TAB has this value, blanks separate fields.  */
+enum { TAB_DEFAULT = CHAR_MAX + 1 };
+
+/* Tab character separating fields.  If TAB_DEFAULT, then fields are
+   separated by the empty string between a non-blank character and a blank
+   character. */
+static int tab = TAB_DEFAULT;
+
+/* Flag to remove consecutive duplicate lines from the output.
+   Only the last of a sequence of equal lines will be output. */
+static bool unique;
+
+/* Nonzero if any of the input files are the standard input. */
+static bool have_read_stdin;
+
+/* List of key field comparisons to be tried.  */
+static struct keyfield *keylist;
+
+/* Program used to (de)compress temp files.  Must accept -d.  */
+static char const *compress_program;
+
+/* Annotate the output with extra info to aid the user.  */
+static bool debug;
+
+/* Maximum number of files to merge in one go.  If more than this
+   number are present, temp files will be used. */
+static unsigned int nmerge = NMERGE_DEFAULT;
+
+/* Report MESSAGE for FILE, then clean up and exit.
+   If FILE is null, it represents standard output.  */
+
+static void die (char const *, char const *) ATTRIBUTE_NORETURN;
+static void
+die (char const *message, char const *file)
+{
+  error (0, errno, "%s: %s", message, file ? file : _("standard output"));
+  exit (SORT_FAILURE);
+}
+
+void
+usage (int status)
+{
+  if (status != EXIT_SUCCESS)
+    emit_try_help ();
+  else
+    {
+      printf (_("\
+Usage: %s [OPTION]... [FILE]...\n\
+  or:  %s [OPTION]... --files0-from=F\n\
+"),
+              program_name, program_name);
+      fputs (_("\
+Write sorted concatenation of all FILE(s) to standard output.\n\
+\n\
+"), stdout);
+      fputs (_("\
+Mandatory arguments to long options are mandatory for short options too.\n\
+"), stdout);
+      fputs (_("\
+Ordering options:\n\
+\n\
+"), stdout);
+      fputs (_("\
+  -b, --ignore-leading-blanks  ignore leading blanks\n\
+  -d, --dictionary-order      consider only blanks and alphanumeric characters\
+\n\
+  -f, --ignore-case           fold lower case to upper case characters\n\
+"), stdout);
+      fputs (_("\
+  -g, --general-numeric-sort  compare according to general numerical value\n\
+  -i, --ignore-nonprinting    consider only printable characters\n\
+  -M, --month-sort            compare (unknown) < 'JAN' < ... < 'DEC'\n\
+"), stdout);
+      fputs (_("\
+  -h, --human-numeric-sort    compare human readable numbers (e.g., 2K 1G)\n\
+"), stdout);
+      fputs (_("\
+  -n, --numeric-sort          compare according to string numerical value\n\
+  -R, --random-sort           sort by random hash of keys\n\
+      --random-source=FILE    get random bytes from FILE\n\
+  -r, --reverse               reverse the result of comparisons\n\
+"), stdout);
+      fputs (_("\
+      --sort=WORD             sort according to WORD:\n\
+                                general-numeric -g, human-numeric -h, month -M,\
+\n\
+                                numeric -n, random -R, version -V\n\
+  -V, --version-sort          natural sort of (version) numbers within text\n\
+\n\
+"), stdout);
+      fputs (_("\
+Other options:\n\
+\n\
+"), stdout);
+      fputs (_("\
+      --batch-size=NMERGE   merge at most NMERGE inputs at once;\n\
+                            for more use temp files\n\
+"), stdout);
+      fputs (_("\
+  -c, --check, --check=diagnose-first  check for sorted input; do not sort\n\
+  -C, --check=quiet, --check=silent  like -c, but do not report first bad line\
+\n\
+      --compress-program=PROG  compress temporaries with PROG;\n\
+                              decompress them with PROG -d\n\
+"), stdout);
+      fputs (_("\
+      --debug               annotate the part of the line used to sort,\n\
+                              and warn about questionable usage to stderr\n\
+      --files0-from=F       read input from the files specified by\n\
+                            NUL-terminated names in file F;\n\
+                            If F is - then read names from standard input\n\
+"), stdout);
+      fputs (_("\
+  -k, --key=KEYDEF          sort via a key; KEYDEF gives location and type\n\
+  -m, --merge               merge already sorted files; do not sort\n\
+"), stdout);
+      fputs (_("\
+  -o, --output=FILE         write result to FILE instead of standard output\n\
+  -s, --stable              stabilize sort by disabling last-resort comparison\
+\n\
+  -S, --buffer-size=SIZE    use SIZE for main memory buffer\n\
+"), stdout);
+      printf (_("\
+  -t, --field-separator=SEP  use SEP instead of non-blank to blank transition\n\
+  -T, --temporary-directory=DIR  use DIR for temporaries, not $TMPDIR or %s;\n\
+                              multiple options specify multiple directories\n\
+      --parallel=N          change the number of sorts run concurrently to N\n\
+  -u, --unique              with -c, check for strict ordering;\n\
+                              without -c, output only the first of an equal run\
+\n\
+"), DEFAULT_TMPDIR);
+      fputs (_("\
+  -z, --zero-terminated     end lines with 0 byte, not newline\n\
+"), stdout);
+      fputs (HELP_OPTION_DESCRIPTION, stdout);
+      fputs (VERSION_OPTION_DESCRIPTION, stdout);
+      fputs (_("\
+\n\
+KEYDEF is F[.C][OPTS][,F[.C][OPTS]] for start and stop position, where F is a\n\
+field number and C a character position in the field; both are origin 1, and\n\
+the stop position defaults to the line's end.  If neither -t nor -b is in\n\
+effect, characters in a field are counted from the beginning of the preceding\n\
+whitespace.  OPTS is one or more single-letter ordering options [bdfgiMhnRrV],\
+\n\
+which override global ordering options for that key.  If no key is given, use\n\
+the entire line as the key.\n\
+\n\
+SIZE may be followed by the following multiplicative suffixes:\n\
+"), stdout);
+      fputs (_("\
+% 1% of memory, b 1, K 1024 (default), and so on for M, G, T, P, E, Z, Y.\n\
+\n\
+With no FILE, or when FILE is -, read standard input.\n\
+\n\
+*** WARNING ***\n\
+The locale specified by the environment affects sort order.\n\
+Set LC_ALL=C to get the traditional sort order that uses\n\
+native byte values.\n\
+"), stdout );
+      emit_ancillary_info ();
+    }
+
+  exit (status);
+}
+
+/* For long options that have no equivalent short option, use a
+   non-character as a pseudo short option, starting with CHAR_MAX + 1.  */
+enum
+{
+  CHECK_OPTION = CHAR_MAX + 1,
+  COMPRESS_PROGRAM_OPTION,
+  DEBUG_PROGRAM_OPTION,
+  FILES0_FROM_OPTION,
+  NMERGE_OPTION,
+  RANDOM_SOURCE_OPTION,
+  SORT_OPTION,
+  PARALLEL_OPTION
+};
+
+static char const short_options[] = "-bcCdfghik:mMno:rRsS:t:T:uVy:z";
+
+static struct option const long_options[] =
+{
+  {"ignore-leading-blanks", no_argument, NULL, 'b'},
+  {"check", optional_argument, NULL, CHECK_OPTION},
+  {"compress-program", required_argument, NULL, COMPRESS_PROGRAM_OPTION},
+  {"debug", no_argument, NULL, DEBUG_PROGRAM_OPTION},
+  {"dictionary-order", no_argument, NULL, 'd'},
+  {"ignore-case", no_argument, NULL, 'f'},
+  {"files0-from", required_argument, NULL, FILES0_FROM_OPTION},
+  {"general-numeric-sort", no_argument, NULL, 'g'},
+  {"ignore-nonprinting", no_argument, NULL, 'i'},
+  {"key", required_argument, NULL, 'k'},
+  {"merge", no_argument, NULL, 'm'},
+  {"month-sort", no_argument, NULL, 'M'},
+  {"numeric-sort", no_argument, NULL, 'n'},
+  {"human-numeric-sort", no_argument, NULL, 'h'},
+  {"version-sort", no_argument, NULL, 'V'},
+  {"random-sort", no_argument, NULL, 'R'},
+  {"random-source", required_argument, NULL, RANDOM_SOURCE_OPTION},
+  {"sort", required_argument, NULL, SORT_OPTION},
+  {"output", required_argument, NULL, 'o'},
+  {"reverse", no_argument, NULL, 'r'},
+  {"stable", no_argument, NULL, 's'},
+  {"batch-size", required_argument, NULL, NMERGE_OPTION},
+  {"buffer-size", required_argument, NULL, 'S'},
+  {"field-separator", required_argument, NULL, 't'},
+  {"temporary-directory", required_argument, NULL, 'T'},
+  {"unique", no_argument, NULL, 'u'},
+  {"zero-terminated", no_argument, NULL, 'z'},
+  {"parallel", required_argument, NULL, PARALLEL_OPTION},
+  {GETOPT_HELP_OPTION_DECL},
+  {GETOPT_VERSION_OPTION_DECL},
+  {NULL, 0, NULL, 0},
+};
+
+#define CHECK_TABLE \
+  _ct_("quiet",          'C') \
+  _ct_("silent",         'C') \
+  _ct_("diagnose-first", 'c')
+
+static char const *const check_args[] =
+{
+#define _ct_(_s, _c) _s,
+  CHECK_TABLE NULL
+#undef  _ct_
+};
+static char const check_types[] =
+{
+#define _ct_(_s, _c) _c,
+  CHECK_TABLE
+#undef  _ct_
+};
+
+#define SORT_TABLE \
+  _st_("general-numeric", 'g') \
+  _st_("human-numeric",   'h') \
+  _st_("month",           'M') \
+  _st_("numeric",         'n') \
+  _st_("random",          'R') \
+  _st_("version",         'V')
+
+static char const *const sort_args[] =
+{
+#define _st_(_s, _c) _s,
+  SORT_TABLE NULL
+#undef  _st_
+};
+static char const sort_types[] =
+{
+#define _st_(_s, _c) _c,
+  SORT_TABLE
+#undef  _st_
+};
+
+/* The set of signals that are caught.  */
+static sigset_t caught_signals;
+
+/* Critical section status.  */
+struct cs_status
+{
+  bool valid;
+  sigset_t sigs;
+};
+
+/* Enter a critical section.  */
+static struct cs_status
+cs_enter (void)
+{
+  struct cs_status status;
+  status.valid = (sigprocmask (SIG_BLOCK, &caught_signals, &status.sigs) == 0);
+  return status;
+}
+
+/* Leave a critical section.  */
+static void
+cs_leave (struct cs_status status)
+{
+  if (status.valid)
+    {
+      /* Ignore failure when restoring the signal mask. */
+      sigprocmask (SIG_SETMASK, &status.sigs, NULL);
+    }
+}
+
+/* Possible states for a temp file.  If compressed, the file's status
+   is unreaped or reaped, depending on whether 'sort' has waited for
+   the subprocess to finish.  */
+enum { UNCOMPRESSED, UNREAPED, REAPED };
+
+/* The list of temporary files. */
+struct tempnode
+{
+  struct tempnode *volatile next;
+  pid_t pid;     /* The subprocess PID; undefined if state == UNCOMPRESSED.  */
+  char state;
+  char name[1];  /* Actual size is 1 + file name length.  */
+};
+static struct tempnode *volatile temphead;
+static struct tempnode *volatile *temptail = &temphead;
+
+/* A file to be sorted.  */
+struct sortfile
+{
+  /* The file's name.  */
+  char const *name;
+
+  /* Nonnull if this is a temporary file, in which case NAME == TEMP->name.  */
+  struct tempnode *temp;
+};
+
+/* Map PIDs of unreaped subprocesses to their struct tempnode objects.  */
+static Hash_table *proctab;
+
+enum { INIT_PROCTAB_SIZE = 47 };
+
+static size_t
+proctab_hasher (void const *entry, size_t tabsize)
+{
+  struct tempnode const *node = entry;
+  return node->pid % tabsize;
+}
+
+static bool
+proctab_comparator (void const *e1, void const *e2)
+{
+  struct tempnode const *n1 = e1;
+  struct tempnode const *n2 = e2;
+  return n1->pid == n2->pid;
+}
+
+/* The number of unreaped child processes.  */
+static pid_t nprocs;
+
+static bool delete_proc (pid_t);
+
+/* If PID is positive, wait for the child process with that PID to
+   exit, and assume that PID has already been removed from the process
+   table.  If PID is 0 or -1, clean up some child that has exited (by
+   waiting for it, and removing it from the proc table) and return the
+   child's process ID.  However, if PID is 0 and no children have
+   exited, return 0 without waiting.  */
+
+static pid_t
+reap (pid_t pid)
+{
+  int status;
+  pid_t cpid = waitpid ((pid ? pid : -1), &status, (pid ? 0 : WNOHANG));
+
+  if (cpid < 0)
+    error (SORT_FAILURE, errno, _("waiting for %s [-d]"),
+           compress_program);
+  else if (0 < cpid && (0 < pid || delete_proc (cpid)))
+    {
+      if (! WIFEXITED (status) || WEXITSTATUS (status))
+        error (SORT_FAILURE, 0, _("%s [-d] terminated abnormally"),
+               compress_program);
+      --nprocs;
+    }
+
+  return cpid;
+}
+
+/* TEMP represents a new process; add it to the process table.  Create
+   the process table the first time it's called.  */
+
+static void
+register_proc (struct tempnode *temp)
+{
+  if (! proctab)
+    {
+      proctab = hash_initialize (INIT_PROCTAB_SIZE, NULL,
+                                 proctab_hasher,
+                                 proctab_comparator,
+                                 NULL);
+      if (! proctab)
+        xalloc_die ();
+    }
+
+  temp->state = UNREAPED;
+
+  if (! hash_insert (proctab, temp))
+    xalloc_die ();
+}
+
+/* If PID is in the process table, remove it and return true.
+   Otherwise, return false.  */
+
+static bool
+delete_proc (pid_t pid)
+{
+  struct tempnode test;
+
+  test.pid = pid;
+  struct tempnode *node = hash_delete (proctab, &test);
+  if (! node)
+    return false;
+  node->state = REAPED;
+  return true;
+}
+
+/* Remove PID from the process table, and wait for it to exit if it
+   hasn't already.  */
+
+static void
+wait_proc (pid_t pid)
+{
+  if (delete_proc (pid))
+    reap (pid);
+}
+
+/* Reap any exited children.  Do not block; reap only those that have
+   already exited.  */
+
+static void
+reap_exited (void)
+{
+  while (0 < nprocs && reap (0))
+    continue;
+}
+
+/* Reap at least one exited child, waiting if necessary.  */
+
+static void
+reap_some (void)
+{
+  reap (-1);
+  reap_exited ();
+}
+
+/* Reap all children, waiting if necessary.  */
+
+static void
+reap_all (void)
+{
+  while (0 < nprocs)
+    reap (-1);
+}
+
+/* Clean up any remaining temporary files.  */
+
+static void
+cleanup (void)
+{
+  struct tempnode const *node;
+
+  for (node = temphead; node; node = node->next)
+    unlink (node->name);
+  temphead = NULL;
+}
+
+/* Cleanup actions to take when exiting.  */
+
+static void
+exit_cleanup (void)
+{
+  if (temphead)
+    {
+      /* Clean up any remaining temporary files in a critical section so
+         that a signal handler does not try to clean them too.  */
+      struct cs_status cs = cs_enter ();
+      cleanup ();
+      cs_leave (cs);
+    }
+
+  close_stdout ();
+}
+
+/* Create a new temporary file, returning its newly allocated tempnode.
+   Store into *PFD the file descriptor open for writing.
+   If the creation fails, return NULL and store -1 into *PFD if the
+   failure is due to file descriptor exhaustion and
+   SURVIVE_FD_EXHAUSTION; otherwise, die.  */
+
+static struct tempnode *
+create_temp_file (int *pfd, bool survive_fd_exhaustion)
+{
+  static char const slashbase[] = "/sortXXXXXX";
+  static size_t temp_dir_index;
+  int fd;
+  int saved_errno;
+  char const *temp_dir = temp_dirs[temp_dir_index];
+  size_t len = strlen (temp_dir);
+  struct tempnode *node =
+    xmalloc (offsetof (struct tempnode, name) + len + sizeof slashbase);
+  char *file = node->name;
+  struct cs_status cs;
+
+  memcpy (file, temp_dir, len);
+  memcpy (file + len, slashbase, sizeof slashbase);
+  node->next = NULL;
+  if (++temp_dir_index == temp_dir_count)
+    temp_dir_index = 0;
+
+  /* Create the temporary file in a critical section, to avoid races.  */
+  cs = cs_enter ();
+  fd = mkstemp (file);
+  if (0 <= fd)
+    {
+      *temptail = node;
+      temptail = &node->next;
+    }
+  saved_errno = errno;
+  cs_leave (cs);
+  errno = saved_errno;
+
+  if (fd < 0)
+    {
+      if (! (survive_fd_exhaustion && errno == EMFILE))
+        error (SORT_FAILURE, errno, _("cannot create temporary file in %s"),
+               quote (temp_dir));
+      free (node);
+      node = NULL;
+    }
+
+  *pfd = fd;
+  return node;
+}
+
+/* Return a stream for FILE, opened with mode HOW.  A null FILE means
+   standard output; HOW should be "w".  When opening for input, "-"
+   means standard input.  To avoid confusion, do not return file
+   descriptors STDIN_FILENO, STDOUT_FILENO, or STDERR_FILENO when
+   opening an ordinary FILE.  Return NULL if unsuccessful.
+
+   fadvise() is used to specify an access pattern for input files.
+   There are a few hints we could possibly provide,
+   and after careful testing it was decided that
+   specifying POSIX_FADV_SEQUENTIAL was not detrimental
+   to any cases.  On Linux 2.6.31, this option doubles
+   the size of read ahead performed and thus was seen to
+   benefit these cases:
+     Merging
+     Sorting with a smaller internal buffer
+     Reading from faster flash devices
+
+   In _addition_ one could also specify other hints...
+
+   POSIX_FADV_WILLNEED was tested, but Linux 2.6.31
+   at least uses that to _synchronously_ prepopulate the cache
+   with the specified range.  While sort does need to
+   read all of its input before outputting, a synchronous
+   read of the whole file up front precludes any processing
+   that sort could do in parallel with the system doing
+   read ahead of the data. This was seen to have negative effects
+   in a couple of cases:
+     Merging
+     Sorting with a smaller internal buffer
+   Note this option was seen to shorten the runtime for sort
+   on a multicore system with lots of RAM and other processes
+   competing for CPU.  It could be argued that more explicit
+   scheduling hints with 'nice' et. al. are more appropriate
+   for this situation.
+
+   POSIX_FADV_NOREUSE is a possibility as it could lower
+   the priority of input data in the cache as sort will
+   only need to process it once.  However its functionality
+   has changed over Linux kernel versions and as of 2.6.31
+   it does nothing and thus we can't depend on what it might
+   do in future.
+
+   POSIX_FADV_DONTNEED is not appropriate for user specified
+   input files, but for temp files we do want to drop the
+   cache immediately after processing.  This is done implicitly
+   however when the files are unlinked.  */
+
+static FILE *
+stream_open (char const *file, char const *how)
+{
+  FILE *fp;
+
+  if (*how == 'r')
+    {
+      if (STREQ (file, "-"))
+        {
+          have_read_stdin = true;
+          fp = stdin;
+        }
+      else
+        fp = fopen (file, how);
+      fadvise (fp, FADVISE_SEQUENTIAL);
+    }
+  else if (*how == 'w')
+    {
+      if (file && ftruncate (STDOUT_FILENO, 0) != 0)
+        error (SORT_FAILURE, errno, _("%s: error truncating"),
+               quote (file));
+      fp = stdout;
+    }
+  else
+    assert (!"unexpected mode passed to stream_open");
+
+  return fp;
+}
+
+/* Same as stream_open, except always return a non-null value; die on
+   failure.  */
+
+static FILE *
+xfopen (char const *file, char const *how)
+{
+  FILE *fp = stream_open (file, how);
+  if (!fp)
+    die (_("open failed"), file);
+  return fp;
+}
+
+/* Close FP, whose name is FILE, and report any errors.  */
+
+static void
+xfclose (FILE *fp, char const *file)
+{
+  switch (fileno (fp))
+    {
+    case STDIN_FILENO:
+      /* Allow reading stdin from tty more than once.  */
+      if (feof (fp))
+        clearerr (fp);
+      break;
+
+    case STDOUT_FILENO:
+      /* Don't close stdout just yet.  close_stdout does that.  */
+      if (fflush (fp) != 0)
+        die (_("fflush failed"), file);
+      break;
+
+    default:
+      if (fclose (fp) != 0)
+        die (_("close failed"), file);
+      break;
+    }
+}
+
+static void
+move_fd_or_die (int oldfd, int newfd)
+{
+  if (oldfd != newfd)
+    {
+      if (dup2 (oldfd, newfd) < 0)
+        error (SORT_FAILURE, errno, _("dup2 failed"));
+      close (oldfd);
+    }
+}
+
+/* Fork a child process for piping to and do common cleanup.  The
+   TRIES parameter tells us how many times to try to fork before
+   giving up.  Return the PID of the child, or -1 (setting errno)
+   on failure. */
+
+static pid_t
+pipe_fork (int pipefds[2], size_t tries)
+{
+#if HAVE_WORKING_FORK
+  struct tempnode *saved_temphead;
+  int saved_errno;
+  double wait_retry = 0.25;
+  pid_t pid IF_LINT ( = -1);
+  struct cs_status cs;
+
+  if (pipe (pipefds) < 0)
+    return -1;
+
+  /* At least NMERGE + 1 subprocesses are needed.  More could be created, but
+     uncontrolled subprocess generation can hurt performance significantly.
+     Allow at most NMERGE + 2 subprocesses, on the theory that there
+     may be some useful parallelism by letting compression for the
+     previous merge finish (1 subprocess) in parallel with the current
+     merge (NMERGE + 1 subprocesses).  */
+
+  if (nmerge + 1 < nprocs)
+    reap_some ();
+
+  while (tries--)
+    {
+      /* This is so the child process won't delete our temp files
+         if it receives a signal before exec-ing.  */
+      cs = cs_enter ();
+      saved_temphead = temphead;
+      temphead = NULL;
+
+      pid = fork ();
+      saved_errno = errno;
+      if (pid)
+        temphead = saved_temphead;
+
+      cs_leave (cs);
+      errno = saved_errno;
+
+      if (0 <= pid || errno != EAGAIN)
+        break;
+      else
+        {
+          xnanosleep (wait_retry);
+          wait_retry *= 2;
+          reap_exited ();
+        }
+    }
+
+  if (pid < 0)
+    {
+      saved_errno = errno;
+      close (pipefds[0]);
+      close (pipefds[1]);
+      errno = saved_errno;
+    }
+  else if (pid == 0)
+    {
+      close (STDIN_FILENO);
+      close (STDOUT_FILENO);
+    }
+  else
+    ++nprocs;
+
+  return pid;
+
+#else  /* ! HAVE_WORKING_FORK */
+  return -1;
+#endif
+}
+
+/* Create a temporary file and, if asked for, start a compressor
+   to that file.  Set *PFP to the file handle and return
+   the address of the new temp node.  If the creation
+   fails, return NULL if the failure is due to file descriptor
+   exhaustion and SURVIVE_FD_EXHAUSTION; otherwise, die.  */
+
+static struct tempnode *
+maybe_create_temp (FILE **pfp, bool survive_fd_exhaustion)
+{
+  int tempfd;
+  struct tempnode *node = create_temp_file (&tempfd, survive_fd_exhaustion);
+  if (! node)
+    return NULL;
+
+  node->state = UNCOMPRESSED;
+
+  if (compress_program)
+    {
+      int pipefds[2];
+
+      node->pid = pipe_fork (pipefds, MAX_FORK_TRIES_COMPRESS);
+      if (0 < node->pid)
+        {
+          close (tempfd);
+          close (pipefds[0]);
+          tempfd = pipefds[1];
+
+          register_proc (node);
+        }
+      else if (node->pid == 0)
+        {
+          close (pipefds[1]);
+          move_fd_or_die (tempfd, STDOUT_FILENO);
+          move_fd_or_die (pipefds[0], STDIN_FILENO);
+
+          if (execlp (compress_program, compress_program, (char *) NULL) < 0)
+            error (SORT_FAILURE, errno, _("couldn't execute %s"),
+                   compress_program);
+        }
+    }
+
+  *pfp = fdopen (tempfd, "w");
+  if (! *pfp)
+    die (_("couldn't create temporary file"), node->name);
+
+  return node;
+}
+
+/* Create a temporary file and, if asked for, start a compressor
+   to that file.  Set *PFP to the file handle and return the address
+   of the new temp node.  Die on failure.  */
+
+static struct tempnode *
+create_temp (FILE **pfp)
+{
+  return maybe_create_temp (pfp, false);
+}
+
+/* Open a compressed temp file and start a decompression process through
+   which to filter the input.  Return NULL (setting errno to
+   EMFILE) if we ran out of file descriptors, and die on any other
+   kind of failure.  */
+
+static FILE *
+open_temp (struct tempnode *temp)
+{
+  int tempfd, pipefds[2];
+  FILE *fp = NULL;
+
+  if (temp->state == UNREAPED)
+    wait_proc (temp->pid);
+
+  tempfd = open (temp->name, O_RDONLY);
+  if (tempfd < 0)
+    return NULL;
+
+  pid_t child = pipe_fork (pipefds, MAX_FORK_TRIES_DECOMPRESS);
+
+  switch (child)
+    {
+    case -1:
+      if (errno != EMFILE)
+        error (SORT_FAILURE, errno, _("couldn't create process for %s -d"),
+               compress_program);
+      close (tempfd);
+      errno = EMFILE;
+      break;
+
+    case 0:
+      close (pipefds[0]);
+      move_fd_or_die (tempfd, STDIN_FILENO);
+      move_fd_or_die (pipefds[1], STDOUT_FILENO);
+
+      execlp (compress_program, compress_program, "-d", (char *) NULL);
+      error (SORT_FAILURE, errno, _("couldn't execute %s -d"),
+             compress_program);
+
+    default:
+      temp->pid = child;
+      register_proc (temp);
+      close (tempfd);
+      close (pipefds[1]);
+
+      fp = fdopen (pipefds[0], "r");
+      if (! fp)
+        {
+          int saved_errno = errno;
+          close (pipefds[0]);
+          errno = saved_errno;
+        }
+      break;
+    }
+
+  return fp;
+}
+
+/* Append DIR to the array of temporary directory names.  */
+static void
+add_temp_dir (char const *dir)
+{
+  if (temp_dir_count == temp_dir_alloc)
+    temp_dirs = X2NREALLOC (temp_dirs, &temp_dir_alloc);
+
+  temp_dirs[temp_dir_count++] = dir;
+}
+
+/* Remove NAME from the list of temporary files.  */
+
+static void
+zaptemp (char const *name)
+{
+  struct tempnode *volatile *pnode;
+  struct tempnode *node;
+  struct tempnode *next;
+  int unlink_status;
+  int unlink_errno = 0;
+  struct cs_status cs;
+
+  for (pnode = &temphead; (node = *pnode)->name != name; pnode = &node->next)
+    continue;
+
+  if (node->state == UNREAPED)
+    wait_proc (node->pid);
+
+  /* Unlink the temporary file in a critical section to avoid races.  */
+  next = node->next;
+  cs = cs_enter ();
+  unlink_status = unlink (name);
+  unlink_errno = errno;
+  *pnode = next;
+  cs_leave (cs);
+
+  if (unlink_status != 0)
+    error (0, unlink_errno, _("warning: cannot remove: %s"), name);
+  if (! next)
+    temptail = pnode;
+  free (node);
+}
+
+#if HAVE_NL_LANGINFO
+
+static int
+struct_month_cmp (void const *m1, void const *m2)
+{
+  struct month const *month1 = m1;
+  struct month const *month2 = m2;
+  return strcmp (month1->name, month2->name);
+}
+
+#endif
+
+/* Initialize the character class tables. */
+
+static void
+inittables (void)
+{
+  size_t i;
+
+  for (i = 0; i < UCHAR_LIM; ++i)
+    {
+      blanks[i] = !! isblank (i);
+      nonprinting[i] = ! isprint (i);
+      nondictionary[i] = ! isalnum (i) && ! isblank (i);
+      fold_toupper[i] = toupper (i);
+    }
+
+#if HAVE_NL_LANGINFO
+  /* If we're not in the "C" locale, read different names for months.  */
+  if (hard_LC_TIME)
+    {
+      for (i = 0; i < MONTHS_PER_YEAR; i++)
+        {
+          char const *s;
+          size_t s_len;
+          size_t j, k;
+          char *name;
+
+          s = nl_langinfo (ABMON_1 + i);
+          s_len = strlen (s);
+          monthtab[i].name = name = xmalloc (s_len + 1);
+          monthtab[i].val = i + 1;
+
+          for (j = k = 0; j < s_len; j++)
+            if (! isblank (to_uchar (s[j])))
+              name[k++] = fold_toupper[to_uchar (s[j])];
+          name[k] = '\0';
+        }
+      qsort (monthtab, MONTHS_PER_YEAR, sizeof *monthtab, struct_month_cmp);
+    }
+#endif
+}
+
+/* Specify how many inputs may be merged at once.
+   This may be set on the command-line with the
+   --batch-size option. */
+static void
+specify_nmerge (int oi, char c, char const *s)
+{
+  uintmax_t n;
+  struct rlimit rlimit;
+  enum strtol_error e = xstrtoumax (s, NULL, 10, &n, NULL);
+
+  /* Try to find out how many file descriptors we'll be able
+     to open.  We need at least nmerge + 3 (STDIN_FILENO,
+     STDOUT_FILENO and STDERR_FILENO). */
+  unsigned int max_nmerge = ((getrlimit (RLIMIT_NOFILE, &rlimit) == 0
+                              ? rlimit.rlim_cur
+                              : OPEN_MAX)
+                             - 3);
+
+  if (e == LONGINT_OK)
+    {
+      nmerge = n;
+      if (nmerge != n)
+        e = LONGINT_OVERFLOW;
+      else
+        {
+          if (nmerge < 2)
+            {
+              error (0, 0, _("invalid --%s argument %s"),
+                     long_options[oi].name, quote (s));
+              error (SORT_FAILURE, 0,
+                     _("minimum --%s argument is %s"),
+                     long_options[oi].name, quote ("2"));
+            }
+          else if (max_nmerge < nmerge)
+            {
+              e = LONGINT_OVERFLOW;
+            }
+          else
+            return;
+        }
+    }
+
+  if (e == LONGINT_OVERFLOW)
+    {
+      char max_nmerge_buf[INT_BUFSIZE_BOUND (max_nmerge)];
+      error (0, 0, _("--%s argument %s too large"),
+             long_options[oi].name, quote (s));
+      error (SORT_FAILURE, 0,
+             _("maximum --%s argument with current rlimit is %s"),
+             long_options[oi].name,
+             uinttostr (max_nmerge, max_nmerge_buf));
+    }
+  else
+    xstrtol_fatal (e, oi, c, long_options, s);
+}
+
+/* Specify the amount of main memory to use when sorting.  */
+static void
+specify_sort_size (int oi, char c, char const *s)
+{
+  uintmax_t n;
+  char *suffix;
+  enum strtol_error e = xstrtoumax (s, &suffix, 10, &n, "EgGkKmMPtTYZ");
+
+  /* The default unit is KiB.  */
+  if (e == LONGINT_OK && ISDIGIT (suffix[-1]))
+    {
+      if (n <= UINTMAX_MAX / 1024)
+        n *= 1024;
+      else
+        e = LONGINT_OVERFLOW;
+    }
+
+  /* A 'b' suffix means bytes; a '%' suffix means percent of memory.  */
+  if (e == LONGINT_INVALID_SUFFIX_CHAR && ISDIGIT (suffix[-1]) && ! suffix[1])
+    switch (suffix[0])
+      {
+      case 'b':
+        e = LONGINT_OK;
+        break;
+
+      case '%':
+        {
+          double mem = physmem_total () * n / 100;
+
+          /* Use "<", not "<=", to avoid problems with rounding.  */
+          if (mem < UINTMAX_MAX)
+            {
+              n = mem;
+              e = LONGINT_OK;
+            }
+          else
+            e = LONGINT_OVERFLOW;
+        }
+        break;
+      }
+
+  if (e == LONGINT_OK)
+    {
+      /* If multiple sort sizes are specified, take the maximum, so
+         that option order does not matter.  */
+      if (n < sort_size)
+        return;
+
+      sort_size = n;
+      if (sort_size == n)
+        {
+          sort_size = MAX (sort_size, MIN_SORT_SIZE);
+          return;
+        }
+
+      e = LONGINT_OVERFLOW;
+    }
+
+  xstrtol_fatal (e, oi, c, long_options, s);
+}
+
+/* Specify the number of threads to spawn during internal sort.  */
+static size_t
+specify_nthreads (int oi, char c, char const *s)
+{
+  unsigned long int nthreads;
+  enum strtol_error e = xstrtoul (s, NULL, 10, &nthreads, "");
+  if (e == LONGINT_OVERFLOW)
+    return SIZE_MAX;
+  if (e != LONGINT_OK)
+    xstrtol_fatal (e, oi, c, long_options, s);
+  if (SIZE_MAX < nthreads)
+    nthreads = SIZE_MAX;
+  if (nthreads == 0)
+    error (SORT_FAILURE, 0, _("number in parallel must be nonzero"));
+  return nthreads;
+}
+
+/* Return the default sort size.  */
+static size_t
+default_sort_size (void)
+{
+  /* Let SIZE be MEM, but no more than the maximum object size,
+     total memory, or system resource limits.  Don't bother to check
+     for values like RLIM_INFINITY since in practice they are not much
+     less than SIZE_MAX.  */
+  size_t size = SIZE_MAX;
+  struct rlimit rlimit;
+  if (getrlimit (RLIMIT_DATA, &rlimit) == 0 && rlimit.rlim_cur < size)
+    size = rlimit.rlim_cur;
+#ifdef RLIMIT_AS
+  if (getrlimit (RLIMIT_AS, &rlimit) == 0 && rlimit.rlim_cur < size)
+    size = rlimit.rlim_cur;
+#endif
+
+  /* Leave a large safety margin for the above limits, as failure can
+     occur when they are exceeded.  */
+  size /= 2;
+
+#ifdef RLIMIT_RSS
+  /* Leave a 1/16 margin for RSS to leave room for code, stack, etc.
+     Exceeding RSS is not fatal, but can be quite slow.  */
+  if (getrlimit (RLIMIT_RSS, &rlimit) == 0 && rlimit.rlim_cur / 16 * 15 < size)
+    size = rlimit.rlim_cur / 16 * 15;
+#endif
+
+  /* Let MEM be available memory or 1/8 of total memory, whichever
+     is greater.  */
+  double avail = physmem_available ();
+  double total = physmem_total ();
+  double mem = MAX (avail, total / 8);
+
+  /* Leave a 1/4 margin for physical memory.  */
+  if (total * 0.75 < size)
+    size = total * 0.75;
+
+  /* Return the minimum of MEM and SIZE, but no less than
+     MIN_SORT_SIZE.  Avoid the MIN macro here, as it is not quite
+     right when only one argument is floating point.  */
+  if (mem < size)
+    size = mem;
+  return MAX (size, MIN_SORT_SIZE);
+}
+
+/* Return the sort buffer size to use with the input files identified
+   by FPS and FILES, which are alternate names of the same files.
+   NFILES gives the number of input files; NFPS may be less.  Assume
+   that each input line requires LINE_BYTES extra bytes' worth of line
+   information.  Do not exceed the size bound specified by the user
+   (or a default size bound, if the user does not specify one).  */
+
+static size_t
+sort_buffer_size (FILE *const *fps, size_t nfps,
+                  char *const *files, size_t nfiles,
+                  size_t line_bytes)
+{
+  /* A bound on the input size.  If zero, the bound hasn't been
+     determined yet.  */
+  static size_t size_bound;
+
+  /* In the worst case, each input byte is a newline.  */
+  size_t worst_case_per_input_byte = line_bytes + 1;
+
+  /* Keep enough room for one extra input line and an extra byte.
+     This extra room might be needed when preparing to read EOF.  */
+  size_t size = worst_case_per_input_byte + 1;
+
+  size_t i;
+
+  for (i = 0; i < nfiles; i++)
+    {
+      struct stat st;
+      off_t file_size;
+      size_t worst_case;
+
+      if ((i < nfps ? fstat (fileno (fps[i]), &st)
+           : STREQ (files[i], "-") ? fstat (STDIN_FILENO, &st)
+           : stat (files[i], &st))
+          != 0)
+        die (_("stat failed"), files[i]);
+
+      if (S_ISREG (st.st_mode))
+        file_size = st.st_size;
+      else
+        {
+          /* The file has unknown size.  If the user specified a sort
+             buffer size, use that; otherwise, guess the size.  */
+          if (sort_size)
+            return sort_size;
+          file_size = INPUT_FILE_SIZE_GUESS;
+        }
+
+      if (! size_bound)
+        {
+          size_bound = sort_size;
+          if (! size_bound)
+            size_bound = default_sort_size ();
+        }
+
+      /* Add the amount of memory needed to represent the worst case
+         where the input consists entirely of newlines followed by a
+         single non-newline.  Check for overflow.  */
+      worst_case = file_size * worst_case_per_input_byte + 1;
+      if (file_size != worst_case / worst_case_per_input_byte
+          || size_bound - size <= worst_case)
+        return size_bound;
+      size += worst_case;
+    }
+
+  return size;
+}
+
+/* Initialize BUF.  Reserve LINE_BYTES bytes for each line; LINE_BYTES
+   must be at least sizeof (struct line).  Allocate ALLOC bytes
+   initially.  */
+
+static void
+initbuf (struct buffer *buf, size_t line_bytes, size_t alloc)
+{
+  /* Ensure that the line array is properly aligned.  If the desired
+     size cannot be allocated, repeatedly halve it until allocation
+     succeeds.  The smaller allocation may hurt overall performance,
+     but that's better than failing.  */
+  while (true)
+    {
+      alloc += sizeof (struct line) - alloc % sizeof (struct line);
+      buf->buf = malloc (alloc);
+      if (buf->buf)
+        break;
+      alloc /= 2;
+      if (alloc <= line_bytes + 1)
+        xalloc_die ();
+    }
+
+  buf->line_bytes = line_bytes;
+  buf->alloc = alloc;
+  buf->used = buf->left = buf->nlines = 0;
+  buf->eof = false;
+}
+
+/* Return one past the limit of the line array.  */
+
+static inline struct line *
+buffer_linelim (struct buffer const *buf)
+{
+  return (struct line *) (buf->buf + buf->alloc);
+}
+
+/* Return a pointer to the first character of the field specified
+   by KEY in LINE. */
+
+static char *
+begfield (struct line const *line, struct keyfield const *key)
+{
+  char *ptr = line->text, *lim = ptr + line->length - 1;
+  size_t sword = key->sword;
+  size_t schar = key->schar;
+
+  /* The leading field separator itself is included in a field when -t
+     is absent.  */
+
+  if (tab != TAB_DEFAULT)
+    while (ptr < lim && sword--)
+      {
+        while (ptr < lim && *ptr != tab)
+          ++ptr;
+        if (ptr < lim)
+          ++ptr;
+      }
+  else
+    while (ptr < lim && sword--)
+      {
+        while (ptr < lim && blanks[to_uchar (*ptr)])
+          ++ptr;
+        while (ptr < lim && !blanks[to_uchar (*ptr)])
+          ++ptr;
+      }
+
+  /* If we're ignoring leading blanks when computing the Start
+     of the field, skip past them here.  */
+  if (key->skipsblanks)
+    while (ptr < lim && blanks[to_uchar (*ptr)])
+      ++ptr;
+
+  /* Advance PTR by SCHAR (if possible), but no further than LIM.  */
+  ptr = MIN (lim, ptr + schar);
+
+  return ptr;
+}
+
+/* Return the limit of (a pointer to the first character after) the field
+   in LINE specified by KEY. */
+
+static char *
+limfield (struct line const *line, struct keyfield const *key)
+{
+  char *ptr = line->text, *lim = ptr + line->length - 1;
+  size_t eword = key->eword, echar = key->echar;
+
+  if (echar == 0)
+    eword++; /* Skip all of end field.  */
+
+  /* Move PTR past EWORD fields or to one past the last byte on LINE,
+     whichever comes first.  If there are more than EWORD fields, leave
+     PTR pointing at the beginning of the field having zero-based index,
+     EWORD.  If a delimiter character was specified (via -t), then that
+     'beginning' is the first character following the delimiting TAB.
+     Otherwise, leave PTR pointing at the first 'blank' character after
+     the preceding field.  */
+  if (tab != TAB_DEFAULT)
+    while (ptr < lim && eword--)
+      {
+        while (ptr < lim && *ptr != tab)
+          ++ptr;
+        if (ptr < lim && (eword || echar))
+          ++ptr;
+      }
+  else
+    while (ptr < lim && eword--)
+      {
+        while (ptr < lim && blanks[to_uchar (*ptr)])
+          ++ptr;
+        while (ptr < lim && !blanks[to_uchar (*ptr)])
+          ++ptr;
+      }
+
+#ifdef POSIX_UNSPECIFIED
+  /* The following block of code makes GNU sort incompatible with
+     standard Unix sort, so it's ifdef'd out for now.
+     The POSIX spec isn't clear on how to interpret this.
+     FIXME: request clarification.
+
+     From: kwzh@gnu.ai.mit.edu (Karl Heuer)
+     Date: Thu, 30 May 96 12:20:41 -0400
+     [Translated to POSIX 1003.1-2001 terminology by Paul Eggert.]
+
+     [...]I believe I've found another bug in 'sort'.
+
+     $ cat /tmp/sort.in
+     a b c 2 d
+     pq rs 1 t
+     $ textutils-1.15/src/sort -k1.7,1.7 </tmp/sort.in
+     a b c 2 d
+     pq rs 1 t
+     $ /bin/sort -k1.7,1.7 </tmp/sort.in
+     pq rs 1 t
+     a b c 2 d
+
+     Unix sort produced the answer I expected: sort on the single character
+     in column 7.  GNU sort produced different results, because it disagrees
+     on the interpretation of the key-end spec "M.N".  Unix sort reads this
+     as "skip M-1 fields, then N-1 characters"; but GNU sort wants it to mean
+     "skip M-1 fields, then either N-1 characters or the rest of the current
+     field, whichever comes first".  This extra clause applies only to
+     key-ends, not key-starts.
+     */
+
+  /* Make LIM point to the end of (one byte past) the current field.  */
+  if (tab != TAB_DEFAULT)
+    {
+      char *newlim;
+      newlim = memchr (ptr, tab, lim - ptr);
+      if (newlim)
+        lim = newlim;
+    }
+  else
+    {
+      char *newlim;
+      newlim = ptr;
+      while (newlim < lim && blanks[to_uchar (*newlim)])
+        ++newlim;
+      while (newlim < lim && !blanks[to_uchar (*newlim)])
+        ++newlim;
+      lim = newlim;
+    }
+#endif
+
+  if (echar != 0) /* We need to skip over a portion of the end field.  */
+    {
+      /* If we're ignoring leading blanks when computing the End
+         of the field, skip past them here.  */
+      if (key->skipeblanks)
+        while (ptr < lim && blanks[to_uchar (*ptr)])
+          ++ptr;
+
+      /* Advance PTR by ECHAR (if possible), but no further than LIM.  */
+      ptr = MIN (lim, ptr + echar);
+    }
+
+  return ptr;
+}
+
+/* Fill BUF reading from FP, moving buf->left bytes from the end
+   of buf->buf to the beginning first.  If EOF is reached and the
+   file wasn't terminated by a newline, supply one.  Set up BUF's line
+   table too.  FILE is the name of the file corresponding to FP.
+   Return true if some input was read.  */
+
+static bool
+fillbuf (struct buffer *buf, FILE *fp, char const *file)
+{
+  struct keyfield const *key = keylist;
+  char eol = eolchar;
+  size_t line_bytes = buf->line_bytes;
+  size_t mergesize = merge_buffer_size - MIN_MERGE_BUFFER_SIZE;
+
+  if (buf->eof)
+    return false;
+
+  if (buf->used != buf->left)
+    {
+      memmove (buf->buf, buf->buf + buf->used - buf->left, buf->left);
+      buf->used = buf->left;
+      buf->nlines = 0;
+    }
+
+  while (true)
+    {
+      char *ptr = buf->buf + buf->used;
+      struct line *linelim = buffer_linelim (buf);
+      struct line *line = linelim - buf->nlines;
+      size_t avail = (char *) linelim - buf->nlines * line_bytes - ptr;
+      char *line_start = buf->nlines ? line->text + line->length : buf->buf;
+
+      while (line_bytes + 1 < avail)
+        {
+          /* Read as many bytes as possible, but do not read so many
+             bytes that there might not be enough room for the
+             corresponding line array.  The worst case is when the
+             rest of the input file consists entirely of newlines,
+             except that the last byte is not a newline.  */
+          size_t readsize = (avail - 1) / (line_bytes + 1);
+          size_t bytes_read = fread (ptr, 1, readsize, fp);
+          char *ptrlim = ptr + bytes_read;
+          char *p;
+          avail -= bytes_read;
+
+          if (bytes_read != readsize)
+            {
+              if (ferror (fp))
+                die (_("read failed"), file);
+              if (feof (fp))
+                {
+                  buf->eof = true;
+                  if (buf->buf == ptrlim)
+                    return false;
+                  if (line_start != ptrlim && ptrlim[-1] != eol)
+                    *ptrlim++ = eol;
+                }
+            }
+
+          /* Find and record each line in the just-read input.  */
+          while ((p = memchr (ptr, eol, ptrlim - ptr)))
+            {
+              /* Delimit the line with NUL. This eliminates the need to
+                 temporarily replace the last byte with NUL when calling
+                 xmemcoll(), which increases performance.  */
+              *p = '\0';
+              ptr = p + 1;
+              line--;
+              line->text = line_start;
+              line->length = ptr - line_start;
+              mergesize = MAX (mergesize, line->length);
+              avail -= line_bytes;
+
+              if (key)
+                {
+                  /* Precompute the position of the first key for
+                     efficiency.  */
+                  line->keylim = (key->eword == SIZE_MAX
+                                  ? p
+                                  : limfield (line, key));
+
+                  if (key->sword != SIZE_MAX)
+                    line->keybeg = begfield (line, key);
+                  else
+                    {
+                      if (key->skipsblanks)
+                        while (blanks[to_uchar (*line_start)])
+                          line_start++;
+                      line->keybeg = line_start;
+                    }
+                }
+
+              line_start = ptr;
+            }
+
+          ptr = ptrlim;
+          if (buf->eof)
+            break;
+        }
+
+      buf->used = ptr - buf->buf;
+      buf->nlines = buffer_linelim (buf) - line;
+      if (buf->nlines != 0)
+        {
+          buf->left = ptr - line_start;
+          merge_buffer_size = mergesize + MIN_MERGE_BUFFER_SIZE;
+          return true;
+        }
+
+      {
+        /* The current input line is too long to fit in the buffer.
+           Increase the buffer size and try again, keeping it properly
+           aligned.  */
+        size_t line_alloc = buf->alloc / sizeof (struct line);
+        buf->buf = x2nrealloc (buf->buf, &line_alloc, sizeof (struct line));
+        buf->alloc = line_alloc * sizeof (struct line);
+      }
+    }
+}
+
+/* Table that maps characters to order-of-magnitude values.  */
+static char const unit_order[UCHAR_LIM] =
+  {
+#if ! ('K' == 75 && 'M' == 77 && 'G' == 71 && 'T' == 84 && 'P' == 80 \
+     && 'E' == 69 && 'Z' == 90 && 'Y' == 89 && 'k' == 107)
+    /* This initializer syntax works on all C99 hosts.  For now, use
+       it only on non-ASCII hosts, to ease the pain of porting to
+       pre-C99 ASCII hosts.  */
+    ['K']=1, ['M']=2, ['G']=3, ['T']=4, ['P']=5, ['E']=6, ['Z']=7, ['Y']=8,
+    ['k']=1,
+#else
+    /* Generate the following table with this command:
+       perl -e 'my %a=(k=>1, K=>1, M=>2, G=>3, T=>4, P=>5, E=>6, Z=>7, Y=>8);
+       foreach my $i (0..255) {my $c=chr($i); $a{$c} ||= 0;print "$a{$c}, "}'\
+       |fmt  */
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 3,
+    0, 0, 0, 1, 0, 2, 0, 0, 5, 0, 0, 0, 4, 0, 0, 0, 0, 8, 7, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+#endif
+  };
+
+/* Return an integer that represents the order of magnitude of the
+   unit following the number.  The number may contain thousands
+   separators and a decimal point, but it may not contain leading blanks.
+   Negative numbers get negative orders; zero numbers have a zero order.  */
+
+static int _GL_ATTRIBUTE_PURE
+find_unit_order (char const *number)
+{
+  bool minus_sign = (*number == '-');
+  char const *p = number + minus_sign;
+  int nonzero = 0;
+  unsigned char ch;
+
+  /* Scan to end of number.
+     Decimals or separators not followed by digits stop the scan.
+     Numbers ending in decimals or separators are thus considered
+     to be lacking in units.
+     FIXME: add support for multibyte thousands_sep and decimal_point.  */
+
+  do
+    {
+      while (ISDIGIT (ch = *p++))
+        nonzero |= ch - '0';
+    }
+  while (ch == thousands_sep);
+
+  if (ch == decimal_point)
+    while (ISDIGIT (ch = *p++))
+      nonzero |= ch - '0';
+
+  if (nonzero)
+    {
+      int order = unit_order[ch];
+      return (minus_sign ? -order : order);
+    }
+  else
+    return 0;
+}
+
+/* Compare numbers A and B ending in units with SI or IEC prefixes
+       <none/unknown> < K/k < M < G < T < P < E < Z < Y  */
+
+static int
+human_numcompare (char const *a, char const *b)
+{
+  while (blanks[to_uchar (*a)])
+    a++;
+  while (blanks[to_uchar (*b)])
+    b++;
+
+  int diff = find_unit_order (a) - find_unit_order (b);
+  return (diff ? diff : strnumcmp (a, b, decimal_point, thousands_sep));
+}
+
+/* Compare strings A and B as numbers without explicitly converting them to
+   machine numbers.  Comparatively slow for short strings, but asymptotically
+   hideously fast. */
+
+static int
+numcompare (char const *a, char const *b)
+{
+  while (blanks[to_uchar (*a)])
+    a++;
+  while (blanks[to_uchar (*b)])
+    b++;
+
+  return strnumcmp (a, b, decimal_point, thousands_sep);
+}
+
+/* Work around a problem whereby the long double value returned by glibc's
+   strtold ("NaN", ...) contains uninitialized bits: clear all bytes of
+   A and B before calling strtold.  FIXME: remove this function once
+   gnulib guarantees that strtold's result is always well defined.  */
+static int
+nan_compare (char const *sa, char const *sb)
+{
+  long_double a;
+  memset (&a, 0, sizeof a);
+  a = strtold (sa, NULL);
+
+  long_double b;
+  memset (&b, 0, sizeof b);
+  b = strtold (sb, NULL);
+
+  return memcmp (&a, &b, sizeof a);
+}
+
+static int
+general_numcompare (char const *sa, char const *sb)
+{
+  /* FIXME: maybe add option to try expensive FP conversion
+     only if A and B can't be compared more cheaply/accurately.  */
+
+  char *ea;
+  char *eb;
+  long_double a = strtold (sa, &ea);
+  long_double b = strtold (sb, &eb);
+
+  /* Put conversion errors at the start of the collating sequence.  */
+  if (sa == ea)
+    return sb == eb ? 0 : -1;
+  if (sb == eb)
+    return 1;
+
+  /* Sort numbers in the usual way, where -0 == +0.  Put NaNs after
+     conversion errors but before numbers; sort them by internal
+     bit-pattern, for lack of a more portable alternative.  */
+  return (a < b ? -1
+          : a > b ? 1
+          : a == b ? 0
+          : b == b ? -1
+          : a == a ? 1
+          : nan_compare (sa, sb));
+}
+
+/* Return an integer in 1..12 of the month name MONTH.
+   Return 0 if the name in S is not recognized.  */
+
+static int
+getmonth (char const *month, char **ea)
+{
+  size_t lo = 0;
+  size_t hi = MONTHS_PER_YEAR;
+
+  while (blanks[to_uchar (*month)])
+    month++;
+
+  do
+    {
+      size_t ix = (lo + hi) / 2;
+      char const *m = month;
+      char const *n = monthtab[ix].name;
+
+      for (;; m++, n++)
+        {
+          if (!*n)
+            {
+              if (ea)
+                *ea = (char *) m;
+              return monthtab[ix].val;
+            }
+          if (to_uchar (fold_toupper[to_uchar (*m)]) < to_uchar (*n))
+            {
+              hi = ix;
+              break;
+            }
+          else if (to_uchar (fold_toupper[to_uchar (*m)]) > to_uchar (*n))
+            {
+              lo = ix + 1;
+              break;
+            }
+        }
+    }
+  while (lo < hi);
+
+  return 0;
+}
+
+/* A randomly chosen MD5 state, used for random comparison.  */
+static struct md5_ctx random_md5_state;
+
+/* Initialize the randomly chosen MD5 state.  */
+
+static void
+random_md5_state_init (char const *random_source)
+{
+  unsigned char buf[MD5_DIGEST_SIZE];
+  struct randread_source *r = randread_new (random_source, sizeof buf);
+  if (! r)
+    die (_("open failed"), random_source);
+  randread (r, buf, sizeof buf);
+  if (randread_free (r) != 0)
+    die (_("close failed"), random_source);
+  md5_init_ctx (&random_md5_state);
+  md5_process_bytes (buf, sizeof buf, &random_md5_state);
+}
+
+/* This is like strxfrm, except it reports any error and exits.  */
+
+static size_t
+xstrxfrm (char *restrict dest, char const *restrict src, size_t destsize)
+{
+  errno = 0;
+  size_t translated_size = strxfrm (dest, src, destsize);
+
+  if (errno)
+    {
+      error (0, errno, _("string transformation failed"));
+      error (0, 0, _("set LC_ALL='C' to work around the problem"));
+      error (SORT_FAILURE, 0,
+             _("the untransformed string was %s"),
+             quotearg_n_style (0, locale_quoting_style, src));
+    }
+
+  return translated_size;
+}
+
+/* Compare the keys TEXTA (of length LENA) and TEXTB (of length LENB)
+   using one or more random hash functions.  TEXTA[LENA] and
+   TEXTB[LENB] must be zero.  */
+
+static int
+compare_random (char *restrict texta, size_t lena,
+                char *restrict textb, size_t lenb)
+{
+  /* XFRM_DIFF records the equivalent of memcmp on the transformed
+     data.  This is used to break ties if there is a checksum
+     collision, and this is good enough given the astronomically low
+     probability of a collision.  */
+  int xfrm_diff = 0;
+
+  char stackbuf[4000];
+  char *buf = stackbuf;
+  size_t bufsize = sizeof stackbuf;
+  void *allocated = NULL;
+  uint32_t dig[2][MD5_DIGEST_SIZE / sizeof (uint32_t)];
+  struct md5_ctx s[2];
+  s[0] = s[1] = random_md5_state;
+
+  if (hard_LC_COLLATE)
+    {
+      char const *lima = texta + lena;
+      char const *limb = textb + lenb;
+
+      while (true)
+        {
+          /* Transform the text into the basis of comparison, so that byte
+             strings that would otherwise considered to be equal are
+             considered equal here even if their bytes differ.
+
+             Each time through this loop, transform one
+             null-terminated string's worth from TEXTA or from TEXTB
+             or both.  That way, there's no need to store the
+             transformation of the whole line, if it contains many
+             null-terminated strings.  */
+
+          /* Store the transformed data into a big-enough buffer.  */
+
+          /* A 3X size guess avoids the overhead of calling strxfrm
+             twice on typical implementations.  Don't worry about
+             size_t overflow, as the guess need not be correct.  */
+          size_t guess_bufsize = 3 * (lena + lenb) + 2;
+          if (bufsize < guess_bufsize)
+            {
+              bufsize = MAX (guess_bufsize, bufsize * 3 / 2);
+              free (allocated);
+              buf = allocated = malloc (bufsize);
+              if (! buf)
+                {
+                  buf = stackbuf;
+                  bufsize = sizeof stackbuf;
+                }
+            }
+
+          size_t sizea =
+            (texta < lima ? xstrxfrm (buf, texta, bufsize) + 1 : 0);
+          bool a_fits = sizea <= bufsize;
+          size_t sizeb =
+            (textb < limb
+             ? (xstrxfrm ((a_fits ? buf + sizea : NULL), textb,
+                          (a_fits ? bufsize - sizea : 0))
+                + 1)
+             : 0);
+
+          if (! (a_fits && sizea + sizeb <= bufsize))
+            {
+              bufsize = sizea + sizeb;
+              if (bufsize < SIZE_MAX / 3)
+                bufsize = bufsize * 3 / 2;
+              free (allocated);
+              buf = allocated = xmalloc (bufsize);
+              if (texta < lima)
+                strxfrm (buf, texta, sizea);
+              if (textb < limb)
+                strxfrm (buf + sizea, textb, sizeb);
+            }
+
+          /* Advance past NULs to the next part of each input string,
+             exiting the loop if both strings are exhausted.  When
+             exiting the loop, prepare to finish off the tiebreaker
+             comparison properly.  */
+          if (texta < lima)
+            texta += strlen (texta) + 1;
+          if (textb < limb)
+            textb += strlen (textb) + 1;
+          if (! (texta < lima || textb < limb))
+            {
+              lena = sizea; texta = buf;
+              lenb = sizeb; textb = buf + sizea;
+              break;
+            }
+
+          /* Accumulate the transformed data in the corresponding
+             checksums.  */
+          md5_process_bytes (buf, sizea, &s[0]);
+          md5_process_bytes (buf + sizea, sizeb, &s[1]);
+
+          /* Update the tiebreaker comparison of the transformed data.  */
+          if (! xfrm_diff)
+            {
+              xfrm_diff = memcmp (buf, buf + sizea, MIN (sizea, sizeb));
+              if (! xfrm_diff)
+                xfrm_diff = (sizea > sizeb) - (sizea < sizeb);
+            }
+        }
+    }
+
+  /* Compute and compare the checksums.  */
+  md5_process_bytes (texta, lena, &s[0]); md5_finish_ctx (&s[0], dig[0]);
+  md5_process_bytes (textb, lenb, &s[1]); md5_finish_ctx (&s[1], dig[1]);
+  int diff = memcmp (dig[0], dig[1], sizeof dig[0]);
+
+  /* Fall back on the tiebreaker if the checksums collide.  */
+  if (! diff)
+    {
+      if (! xfrm_diff)
+        {
+          xfrm_diff = memcmp (texta, textb, MIN (lena, lenb));
+          if (! xfrm_diff)
+            xfrm_diff = (lena > lenb) - (lena < lenb);
+        }
+
+      diff = xfrm_diff;
+    }
+
+  free (allocated);
+
+  return diff;
+}
+
+/* Return the printable width of the block of memory starting at
+   TEXT and ending just before LIM, counting each tab as one byte.
+   FIXME: Should we generally be counting non printable chars?  */
+
+static size_t
+debug_width (char const *text, char const *lim)
+{
+  size_t width = mbsnwidth (text, lim - text, 0);
+  while (text < lim)
+    width += (*text++ == '\t');
+  return width;
+}
+
+/* For debug mode, "underline" a key at the
+   specified offset and screen width.  */
+
+static void
+mark_key (size_t offset, size_t width)
+{
+  while (offset--)
+    putchar (' ');
+
+  if (!width)
+    printf (_("^ no match for key\n"));
+  else
+    {
+      do
+        putchar ('_');
+      while (--width);
+
+      putchar ('\n');
+    }
+}
+
+/* Return true if KEY is a numeric key.  */
+
+static inline bool
+key_numeric (struct keyfield const *key)
+{
+  return key->numeric || key->general_numeric || key->human_numeric;
+}
+
+/* For LINE, output a debugging line that underlines KEY in LINE.
+   If KEY is null, underline the whole line.  */
+
+static void
+debug_key (struct line const *line, struct keyfield const *key)
+{
+  char *text = line->text;
+  char *beg = text;
+  char *lim = text + line->length - 1;
+
+  if (key)
+    {
+      if (key->sword != SIZE_MAX)
+        beg = begfield (line, key);
+      if (key->eword != SIZE_MAX)
+        lim = limfield (line, key);
+
+      if (key->skipsblanks || key->month || key_numeric (key))
+        {
+          char saved = *lim;
+          *lim = '\0';
+
+          while (blanks[to_uchar (*beg)])
+            beg++;
+
+          char *tighter_lim = beg;
+
+          if (lim < beg)
+            tighter_lim = lim;
+          else if (key->month)
+            getmonth (beg, &tighter_lim);
+          else if (key->general_numeric)
+            ignore_value (strtold (beg, &tighter_lim));
+          else if (key->numeric || key->human_numeric)
+            {
+              char *p = beg + (beg < lim && *beg == '-');
+              bool found_digit = false;
+              unsigned char ch;
+
+              do
+                {
+                  while (ISDIGIT (ch = *p++))
+                    found_digit = true;
+                }
+              while (ch == thousands_sep);
+
+              if (ch == decimal_point)
+                while (ISDIGIT (ch = *p++))
+                  found_digit = true;
+
+              if (found_digit)
+                tighter_lim = p - ! (key->human_numeric && unit_order[ch]);
+            }
+          else
+            tighter_lim = lim;
+
+          *lim = saved;
+          lim = tighter_lim;
+        }
+    }
+
+  size_t offset = debug_width (text, beg);
+  size_t width = debug_width (beg, lim);
+  mark_key (offset, width);
+}
+
+/* Debug LINE by underlining its keys.  */
+
+static void
+debug_line (struct line const *line)
+{
+  struct keyfield const *key = keylist;
+
+  do
+    debug_key (line, key);
+  while (key && ((key = key->next) || ! (unique || stable)));
+}
+
+/* Return whether sorting options specified for key.  */
+
+static bool
+default_key_compare (struct keyfield const *key)
+{
+  return ! (key->ignore
+            || key->translate
+            || key->skipsblanks
+            || key->skipeblanks
+            || key_numeric (key)
+            || key->month
+            || key->version
+            || key->random
+            /* || key->reverse */
+           );
+}
+
+/* Convert a key to the short options used to specify it.  */
+
+static void
+key_to_opts (struct keyfield const *key, char *opts)
+{
+  if (key->skipsblanks || key->skipeblanks)
+    *opts++ = 'b';/* either disables global -b  */
+  if (key->ignore == nondictionary)
+    *opts++ = 'd';
+  if (key->translate)
+    *opts++ = 'f';
+  if (key->general_numeric)
+    *opts++ = 'g';
+  if (key->human_numeric)
+    *opts++ = 'h';
+  if (key->ignore == nonprinting)
+    *opts++ = 'i';
+  if (key->month)
+    *opts++ = 'M';
+  if (key->numeric)
+    *opts++ = 'n';
+  if (key->random)
+    *opts++ = 'R';
+  if (key->reverse)
+    *opts++ = 'r';
+  if (key->version)
+    *opts++ = 'V';
+  *opts = '\0';
+}
+
+/* Output data independent key warnings to stderr.  */
+
+static void
+key_warnings (struct keyfield const *gkey, bool gkey_only)
+{
+  struct keyfield const *key;
+  struct keyfield ugkey = *gkey;
+  unsigned long keynum = 1;
+
+  for (key = keylist; key; key = key->next, keynum++)
+    {
+      if (key->obsolete_used)
+        {
+          size_t sword = key->sword;
+          size_t eword = key->eword;
+          char tmp[INT_BUFSIZE_BOUND (uintmax_t)];
+          /* obsolescent syntax +A.x -B.y is equivalent to:
+               -k A+1.x+1,B.y   (when y = 0)
+               -k A+1.x+1,B+1.y (when y > 0)  */
+          char obuf[INT_BUFSIZE_BOUND (sword) * 2 + 4]; /* +# -#  */
+          char nbuf[INT_BUFSIZE_BOUND (sword) * 2 + 5]; /* -k #,#  */
+          char *po = obuf;
+          char *pn = nbuf;
+
+          if (sword == SIZE_MAX)
+            sword++;
+
+          po = stpcpy (stpcpy (po, "+"), umaxtostr (sword, tmp));
+          pn = stpcpy (stpcpy (pn, "-k "), umaxtostr (sword + 1, tmp));
+          if (key->eword != SIZE_MAX)
+            {
+              stpcpy (stpcpy (po, " -"), umaxtostr (eword + 1, tmp));
+              stpcpy (stpcpy (pn, ","),
+                      umaxtostr (eword + 1
+                                 + (key->echar == SIZE_MAX), tmp));
+            }
+          error (0, 0, _("obsolescent key %s used; consider %s instead"),
+                 quote_n (0, obuf), quote_n (1, nbuf));
+        }
+
+      /* Warn about field specs that will never match.  */
+      if (key->sword != SIZE_MAX && key->eword < key->sword)
+        error (0, 0, _("key %lu has zero width and will be ignored"), keynum);
+
+      /* Warn about significant leading blanks.  */
+      bool implicit_skip = key_numeric (key) || key->month;
+      bool maybe_space_aligned = !hard_LC_COLLATE && default_key_compare (key)
+                                 && !(key->schar || key->echar);
+      bool line_offset = key->eword == 0 && key->echar != 0; /* -k1.x,1.y  */
+      if (!gkey_only && tab == TAB_DEFAULT && !line_offset
+          && ((!key->skipsblanks && !(implicit_skip || maybe_space_aligned))
+              || (!key->skipsblanks && key->schar)
+              || (!key->skipeblanks && key->echar)))
+        error (0, 0, _("leading blanks are significant in key %lu; "
+                       "consider also specifying 'b'"), keynum);
+
+      /* Warn about numeric comparisons spanning fields,
+         as field delimiters could be interpreted as part
+         of the number (maybe only in other locales).  */
+      if (!gkey_only && key_numeric (key))
+        {
+          size_t sword = key->sword + 1;
+          size_t eword = key->eword + 1;
+          if (!sword)
+            sword++;
+          if (!eword || sword < eword)
+            error (0, 0, _("key %lu is numeric and spans multiple fields"),
+                   keynum);
+        }
+
+      /* Flag global options not copied or specified in any key.  */
+      if (ugkey.ignore && (ugkey.ignore == key->ignore))
+        ugkey.ignore = NULL;
+      if (ugkey.translate && (ugkey.translate == key->translate))
+        ugkey.translate = NULL;
+      ugkey.skipsblanks &= !key->skipsblanks;
+      ugkey.skipeblanks &= !key->skipeblanks;
+      ugkey.month &= !key->month;
+      ugkey.numeric &= !key->numeric;
+      ugkey.general_numeric &= !key->general_numeric;
+      ugkey.human_numeric &= !key->human_numeric;
+      ugkey.random &= !key->random;
+      ugkey.version &= !key->version;
+      ugkey.reverse &= !key->reverse;
+    }
+
+  /* Warn about ignored global options flagged above.
+     Note if gkey is the only one in the list, all flags are cleared.  */
+  if (!default_key_compare (&ugkey)
+      || (ugkey.reverse && (stable || unique) && keylist))
+    {
+      bool ugkey_reverse = ugkey.reverse;
+      if (!(stable || unique))
+        ugkey.reverse = false;
+      /* The following is too big, but guaranteed to be "big enough".  */
+      char opts[sizeof short_options];
+      key_to_opts (&ugkey, opts);
+      error (0, 0,
+             ngettext ("option '-%s' is ignored",
+                       "options '-%s' are ignored",
+                       select_plural (strlen (opts))), opts);
+      ugkey.reverse = ugkey_reverse;
+    }
+  if (ugkey.reverse && !(stable || unique) && keylist)
+    error (0, 0, _("option '-r' only applies to last-resort comparison"));
+}
+
+/* Compare two lines A and B trying every key in sequence until there
+   are no more keys or a difference is found. */
+
+static int
+keycompare (struct line const *a, struct line const *b)
+{
+  struct keyfield *key = keylist;
+
+  /* For the first iteration only, the key positions have been
+     precomputed for us. */
+  char *texta = a->keybeg;
+  char *textb = b->keybeg;
+  char *lima = a->keylim;
+  char *limb = b->keylim;
+
+  int diff;
+
+  while (true)
+    {
+      char const *translate = key->translate;
+      bool const *ignore = key->ignore;
+
+      /* Treat field ends before field starts as empty fields.  */
+      lima = MAX (texta, lima);
+      limb = MAX (textb, limb);
+
+      /* Find the lengths. */
+      size_t lena = lima - texta;
+      size_t lenb = limb - textb;
+
+      if (hard_LC_COLLATE || key_numeric (key)
+          || key->month || key->random || key->version)
+        {
+          char *ta;
+          char *tb;
+          size_t tlena;
+          size_t tlenb;
+
+          char enda IF_LINT (= 0);
+          char endb IF_LINT (= 0);
+          void *allocated IF_LINT (= NULL);
+          char stackbuf[4000];
+
+          if (ignore || translate)
+            {
+              /* Compute with copies of the keys, which are the result of
+                 translating or ignoring characters, and which need their
+                 own storage.  */
+
+              size_t i;
+
+              /* Allocate space for copies.  */
+              size_t size = lena + 1 + lenb + 1;
+              if (size <= sizeof stackbuf)
+                ta = stackbuf, allocated = NULL;
+              else
+                ta = allocated = xmalloc (size);
+              tb = ta + lena + 1;
+
+              /* Put into each copy a version of the key in which the
+                 requested characters are ignored or translated.  */
+              for (tlena = i = 0; i < lena; i++)
+                if (! (ignore && ignore[to_uchar (texta[i])]))
+                  ta[tlena++] = (translate
+                                 ? translate[to_uchar (texta[i])]
+                                 : texta[i]);
+              ta[tlena] = '\0';
+
+              for (tlenb = i = 0; i < lenb; i++)
+                if (! (ignore && ignore[to_uchar (textb[i])]))
+                  tb[tlenb++] = (translate
+                                 ? translate[to_uchar (textb[i])]
+                                 : textb[i]);
+              tb[tlenb] = '\0';
+            }
+          else
+            {
+              /* Use the keys in-place, temporarily null-terminated.  */
+              ta = texta; tlena = lena; enda = ta[tlena]; ta[tlena] = '\0';
+              tb = textb; tlenb = lenb; endb = tb[tlenb]; tb[tlenb] = '\0';
+            }
+
+          if (key->numeric)
+            diff = numcompare (ta, tb);
+          else if (key->general_numeric)
+            diff = general_numcompare (ta, tb);
+          else if (key->human_numeric)
+            diff = human_numcompare (ta, tb);
+          else if (key->month)
+            diff = getmonth (ta, NULL) - getmonth (tb, NULL);
+          else if (key->random)
+            diff = compare_random (ta, tlena, tb, tlenb);
+          else if (key->version)
+            diff = filevercmp (ta, tb);
+          else
+            {
+              /* Locale-dependent string sorting.  This is slower than
+                 C-locale sorting, which is implemented below.  */
+              if (tlena == 0)
+                diff = - NONZERO (tlenb);
+              else if (tlenb == 0)
+                diff = 1;
+              else
+                diff = xmemcoll0 (ta, tlena + 1, tb, tlenb + 1);
+            }
+
+          if (ignore || translate)
+            free (allocated);
+          else
+            {
+              ta[tlena] = enda;
+              tb[tlenb] = endb;
+            }
+        }
+      else if (ignore)
+        {
+#define CMP_WITH_IGNORE(A, B)						\
+  do									\
+    {									\
+          while (true)							\
+            {								\
+              while (texta < lima && ignore[to_uchar (*texta)])		\
+                ++texta;						\
+              while (textb < limb && ignore[to_uchar (*textb)])		\
+                ++textb;						\
+              if (! (texta < lima && textb < limb))			\
+                break;							\
+              diff = to_uchar (A) - to_uchar (B);			\
+              if (diff)							\
+                goto not_equal;						\
+              ++texta;							\
+              ++textb;							\
+            }								\
+                                                                        \
+          diff = (texta < lima) - (textb < limb);			\
+    }									\
+  while (0)
+
+          if (translate)
+            CMP_WITH_IGNORE (translate[to_uchar (*texta)],
+                             translate[to_uchar (*textb)]);
+          else
+            CMP_WITH_IGNORE (*texta, *textb);
+        }
+      else if (lena == 0)
+        diff = - NONZERO (lenb);
+      else if (lenb == 0)
+        goto greater;
+      else
+        {
+          if (translate)
+            {
+              while (texta < lima && textb < limb)
+                {
+                  diff = (to_uchar (translate[to_uchar (*texta++)])
+                          - to_uchar (translate[to_uchar (*textb++)]));
+                  if (diff)
+                    goto not_equal;
+                }
+            }
+          else
+            {
+              diff = memcmp (texta, textb, MIN (lena, lenb));
+              if (diff)
+                goto not_equal;
+            }
+          diff = lena < lenb ? -1 : lena != lenb;
+        }
+
+      if (diff)
+        goto not_equal;
+
+      key = key->next;
+      if (! key)
+        break;
+
+      /* Find the beginning and limit of the next field.  */
+      if (key->eword != SIZE_MAX)
+        lima = limfield (a, key), limb = limfield (b, key);
+      else
+        lima = a->text + a->length - 1, limb = b->text + b->length - 1;
+
+      if (key->sword != SIZE_MAX)
+        texta = begfield (a, key), textb = begfield (b, key);
+      else
+        {
+          texta = a->text, textb = b->text;
+          if (key->skipsblanks)
+            {
+              while (texta < lima && blanks[to_uchar (*texta)])
+                ++texta;
+              while (textb < limb && blanks[to_uchar (*textb)])
+                ++textb;
+            }
+        }
+    }
+
+  return 0;
+
+ greater:
+  diff = 1;
+ not_equal:
+  return key->reverse ? -diff : diff;
+}
+
+/* Compare two lines A and B, returning negative, zero, or positive
+   depending on whether A compares less than, equal to, or greater than B. */
+
+static int
+compare (struct line const *a, struct line const *b)
+{
+  int diff;
+  size_t alen, blen;
+
+  /* First try to compare on the specified keys (if any).
+     The only two cases with no key at all are unadorned sort,
+     and unadorned sort -r. */
+  if (keylist)
+    {
+      diff = keycompare (a, b);
+      if (diff || unique || stable)
+        return diff;
+    }
+
+  /* If the keys all compare equal (or no keys were specified)
+     fall through to the default comparison.  */
+  alen = a->length - 1, blen = b->length - 1;
+
+  if (alen == 0)
+    diff = - NONZERO (blen);
+  else if (blen == 0)
+    diff = 1;
+  else if (hard_LC_COLLATE)
+    {
+      /* Note xmemcoll0 is a performance enhancement as
+         it will not unconditionally write '\0' after the
+         passed in buffers, which was seen to give around
+         a 3% increase in performance for short lines.  */
+      diff = xmemcoll0 (a->text, alen + 1, b->text, blen + 1);
+    }
+  else if (! (diff = memcmp (a->text, b->text, MIN (alen, blen))))
+    diff = alen < blen ? -1 : alen != blen;
+
+  return reverse ? -diff : diff;
+}
+
+/* Write LINE to output stream FP; the output file's name is
+   OUTPUT_FILE if OUTPUT_FILE is nonnull, and is the standard output
+   otherwise.  If debugging is enabled and FP is standard output,
+   append some debugging information.  */
+
+static void
+write_line (struct line const *line, FILE *fp, char const *output_file)
+{
+  char *buf = line->text;
+  size_t n_bytes = line->length;
+  char *ebuf = buf + n_bytes;
+
+  if (!output_file && debug)
+    {
+      /* Convert TAB to '>' and EOL to \n, and then output debugging info.  */
+      char const *c = buf;
+
+      while (c < ebuf)
+        {
+          char wc = *c++;
+          if (wc == '\t')
+            wc = '>';
+          else if (c == ebuf)
+            wc = '\n';
+          if (fputc (wc, fp) == EOF)
+            die (_("write failed"), output_file);
+        }
+
+      debug_line (line);
+    }
+  else
+    {
+      ebuf[-1] = eolchar;
+      if (fwrite (buf, 1, n_bytes, fp) != n_bytes)
+        die (_("write failed"), output_file);
+      ebuf[-1] = '\0';
+    }
+}
+
+/* Check that the lines read from FILE_NAME come in order.  Return
+   true if they are in order.  If CHECKONLY == 'c', also print a
+   diagnostic (FILE_NAME, line number, contents of line) to stderr if
+   they are not in order.  */
+
+static bool
+check (char const *file_name, char checkonly)
+{
+  FILE *fp = xfopen (file_name, "r");
+  struct buffer buf;		/* Input buffer. */
+  struct line temp;		/* Copy of previous line. */
+  size_t alloc = 0;
+  uintmax_t line_number = 0;
+  struct keyfield const *key = keylist;
+  bool nonunique = ! unique;
+  bool ordered = true;
+
+  initbuf (&buf, sizeof (struct line),
+           MAX (merge_buffer_size, sort_size));
+  temp.text = NULL;
+
+  while (fillbuf (&buf, fp, file_name))
+    {
+      struct line const *line = buffer_linelim (&buf);
+      struct line const *linebase = line - buf.nlines;
+
+      /* Make sure the line saved from the old buffer contents is
+         less than or equal to the first line of the new buffer. */
+      if (alloc && nonunique <= compare (&temp, line - 1))
+        {
+        found_disorder:
+          {
+            if (checkonly == 'c')
+              {
+                struct line const *disorder_line = line - 1;
+                uintmax_t disorder_line_number =
+                  buffer_linelim (&buf) - disorder_line + line_number;
+                char hr_buf[INT_BUFSIZE_BOUND (disorder_line_number)];
+                fprintf (stderr, _("%s: %s:%s: disorder: "),
+                         program_name, file_name,
+                         umaxtostr (disorder_line_number, hr_buf));
+                write_line (disorder_line, stderr, _("standard error"));
+              }
+
+            ordered = false;
+            break;
+          }
+        }
+
+      /* Compare each line in the buffer with its successor.  */
+      while (linebase < --line)
+        if (nonunique <= compare (line, line - 1))
+          goto found_disorder;
+
+      line_number += buf.nlines;
+
+      /* Save the last line of the buffer.  */
+      if (alloc < line->length)
+        {
+          do
+            {
+              alloc *= 2;
+              if (! alloc)
+                {
+                  alloc = line->length;
+                  break;
+                }
+            }
+          while (alloc < line->length);
+
+          free (temp.text);
+          temp.text = xmalloc (alloc);
+        }
+      memcpy (temp.text, line->text, line->length);
+      temp.length = line->length;
+      if (key)
+        {
+          temp.keybeg = temp.text + (line->keybeg - line->text);
+          temp.keylim = temp.text + (line->keylim - line->text);
+        }
+    }
+
+  xfclose (fp, file_name);
+  free (buf.buf);
+  free (temp.text);
+  return ordered;
+}
+
+/* Open FILES (there are NFILES of them) and store the resulting array
+   of stream pointers into (*PFPS).  Allocate the array.  Return the
+   number of successfully opened files, setting errno if this value is
+   less than NFILES.  */
+
+static size_t
+open_input_files (struct sortfile *files, size_t nfiles, FILE ***pfps)
+{
+  FILE **fps = *pfps = xnmalloc (nfiles, sizeof *fps);
+  int i;
+
+  /* Open as many input files as we can.  */
+  for (i = 0; i < nfiles; i++)
+    {
+      fps[i] = (files[i].temp && files[i].temp->state != UNCOMPRESSED
+                ? open_temp (files[i].temp)
+                : stream_open (files[i].name, "r"));
+      if (!fps[i])
+        break;
+    }
+
+  return i;
+}
+
+/* Merge lines from FILES onto OFP.  NTEMPS is the number of temporary
+   files (all of which are at the start of the FILES array), and
+   NFILES is the number of files; 0 <= NTEMPS <= NFILES <= NMERGE.
+   FPS is the vector of open stream corresponding to the files.
+   Close input and output streams before returning.
+   OUTPUT_FILE gives the name of the output file.  If it is NULL,
+   the output file is standard output.  */
+
+static void
+mergefps (struct sortfile *files, size_t ntemps, size_t nfiles,
+          FILE *ofp, char const *output_file, FILE **fps)
+{
+  struct buffer *buffer = xnmalloc (nfiles, sizeof *buffer);
+                                /* Input buffers for each file. */
+  struct line saved;		/* Saved line storage for unique check. */
+  struct line const *savedline = NULL;
+                                /* &saved if there is a saved line. */
+  size_t savealloc = 0;		/* Size allocated for the saved line. */
+  struct line const **cur = xnmalloc (nfiles, sizeof *cur);
+                                /* Current line in each line table. */
+  struct line const **base = xnmalloc (nfiles, sizeof *base);
+                                /* Base of each line table.  */
+  size_t *ord = xnmalloc (nfiles, sizeof *ord);
+                                /* Table representing a permutation of fps,
+                                   such that cur[ord[0]] is the smallest line
+                                   and will be next output. */
+  size_t i;
+  size_t j;
+  size_t t;
+  struct keyfield const *key = keylist;
+  saved.text = NULL;
+
+  /* Read initial lines from each input file. */
+  for (i = 0; i < nfiles; )
+    {
+      initbuf (&buffer[i], sizeof (struct line),
+               MAX (merge_buffer_size, sort_size / nfiles));
+      if (fillbuf (&buffer[i], fps[i], files[i].name))
+        {
+          struct line const *linelim = buffer_linelim (&buffer[i]);
+          cur[i] = linelim - 1;
+          base[i] = linelim - buffer[i].nlines;
+          i++;
+        }
+      else
+        {
+          /* fps[i] is empty; eliminate it from future consideration.  */
+          xfclose (fps[i], files[i].name);
+          if (i < ntemps)
+            {
+              ntemps--;
+              zaptemp (files[i].name);
+            }
+          free (buffer[i].buf);
+          --nfiles;
+          for (j = i; j < nfiles; ++j)
+            {
+              files[j] = files[j + 1];
+              fps[j] = fps[j + 1];
+            }
+        }
+    }
+
+  /* Set up the ord table according to comparisons among input lines.
+     Since this only reorders two items if one is strictly greater than
+     the other, it is stable. */
+  for (i = 0; i < nfiles; ++i)
+    ord[i] = i;
+  for (i = 1; i < nfiles; ++i)
+    if (0 < compare (cur[ord[i - 1]], cur[ord[i]]))
+      t = ord[i - 1], ord[i - 1] = ord[i], ord[i] = t, i = 0;
+
+  /* Repeatedly output the smallest line until no input remains. */
+  while (nfiles)
+    {
+      struct line const *smallest = cur[ord[0]];
+
+      /* If uniquified output is turned on, output only the first of
+         an identical series of lines. */
+      if (unique)
+        {
+          if (savedline && compare (savedline, smallest))
+            {
+              savedline = NULL;
+              write_line (&saved, ofp, output_file);
+            }
+          if (!savedline)
+            {
+              savedline = &saved;
+              if (savealloc < smallest->length)
+                {
+                  do
+                    if (! savealloc)
+                      {
+                        savealloc = smallest->length;
+                        break;
+                      }
+                  while ((savealloc *= 2) < smallest->length);
+
+                  free (saved.text);
+                  saved.text = xmalloc (savealloc);
+                }
+              saved.length = smallest->length;
+              memcpy (saved.text, smallest->text, saved.length);
+              if (key)
+                {
+                  saved.keybeg =
+                    saved.text + (smallest->keybeg - smallest->text);
+                  saved.keylim =
+                    saved.text + (smallest->keylim - smallest->text);
+                }
+            }
+        }
+      else
+        write_line (smallest, ofp, output_file);
+
+      /* Check if we need to read more lines into core. */
+      if (base[ord[0]] < smallest)
+        cur[ord[0]] = smallest - 1;
+      else
+        {
+          if (fillbuf (&buffer[ord[0]], fps[ord[0]], files[ord[0]].name))
+            {
+              struct line const *linelim = buffer_linelim (&buffer[ord[0]]);
+              cur[ord[0]] = linelim - 1;
+              base[ord[0]] = linelim - buffer[ord[0]].nlines;
+            }
+          else
+            {
+              /* We reached EOF on fps[ord[0]].  */
+              for (i = 1; i < nfiles; ++i)
+                if (ord[i] > ord[0])
+                  --ord[i];
+              --nfiles;
+              xfclose (fps[ord[0]], files[ord[0]].name);
+              if (ord[0] < ntemps)
+                {
+                  ntemps--;
+                  zaptemp (files[ord[0]].name);
+                }
+              free (buffer[ord[0]].buf);
+              for (i = ord[0]; i < nfiles; ++i)
+                {
+                  fps[i] = fps[i + 1];
+                  files[i] = files[i + 1];
+                  buffer[i] = buffer[i + 1];
+                  cur[i] = cur[i + 1];
+                  base[i] = base[i + 1];
+                }
+              for (i = 0; i < nfiles; ++i)
+                ord[i] = ord[i + 1];
+              continue;
+            }
+        }
+
+      /* The new line just read in may be larger than other lines
+         already in main memory; push it back in the queue until we
+         encounter a line larger than it.  Optimize for the common
+         case where the new line is smallest.  */
+      {
+        size_t lo = 1;
+        size_t hi = nfiles;
+        size_t probe = lo;
+        size_t ord0 = ord[0];
+        size_t count_of_smaller_lines;
+
+        while (lo < hi)
+          {
+            int cmp = compare (cur[ord0], cur[ord[probe]]);
+            if (cmp < 0 || (cmp == 0 && ord0 < ord[probe]))
+              hi = probe;
+            else
+              lo = probe + 1;
+            probe = (lo + hi) / 2;
+          }
+
+        count_of_smaller_lines = lo - 1;
+        for (j = 0; j < count_of_smaller_lines; j++)
+          ord[j] = ord[j + 1];
+        ord[count_of_smaller_lines] = ord0;
+      }
+    }
+
+  if (unique && savedline)
+    {
+      write_line (&saved, ofp, output_file);
+      free (saved.text);
+    }
+
+  xfclose (ofp, output_file);
+  free (fps);
+  free (buffer);
+  free (ord);
+  free (base);
+  free (cur);
+}
+
+/* Merge lines from FILES onto OFP.  NTEMPS is the number of temporary
+   files (all of which are at the start of the FILES array), and
+   NFILES is the number of files; 0 <= NTEMPS <= NFILES <= NMERGE.
+   Close input and output files before returning.
+   OUTPUT_FILE gives the name of the output file.
+
+   Return the number of files successfully merged.  This number can be
+   less than NFILES if we ran low on file descriptors, but in this
+   case it is never less than 2.  */
+
+static size_t
+mergefiles (struct sortfile *files, size_t ntemps, size_t nfiles,
+            FILE *ofp, char const *output_file)
+{
+  FILE **fps;
+  size_t nopened = open_input_files (files, nfiles, &fps);
+  if (nopened < nfiles && nopened < 2)
+    die (_("open failed"), files[nopened].name);
+  mergefps (files, ntemps, nopened, ofp, output_file, fps);
+  return nopened;
+}
+
+/* Merge into T (of size NLINES) the two sorted arrays of lines
+   LO (with NLINES / 2 members), and
+   T - (NLINES / 2) (with NLINES - NLINES / 2 members).
+   T and LO point just past their respective arrays, and the arrays
+   are in reverse order.  NLINES must be at least 2.  */
+
+static void
+mergelines (struct line *restrict t, size_t nlines,
+            struct line const *restrict lo)
+{
+  size_t nlo = nlines / 2;
+  size_t nhi = nlines - nlo;
+  struct line *hi = t - nlo;
+
+  while (true)
+    if (compare (lo - 1, hi - 1) <= 0)
+      {
+        *--t = *--lo;
+        if (! --nlo)
+          {
+            /* HI must equal T now, and there is no need to copy from
+               HI to T. */
+            return;
+          }
+      }
+    else
+      {
+        *--t = *--hi;
+        if (! --nhi)
+          {
+            do
+              *--t = *--lo;
+            while (--nlo);
+
+            return;
+          }
+      }
+}
+
+/* Sort the array LINES with NLINES members, using TEMP for temporary space.
+   Do this all within one thread.  NLINES must be at least 2.
+   If TO_TEMP, put the sorted output into TEMP, and TEMP is as large as LINES.
+   Otherwise the sort is in-place and TEMP is half-sized.
+   The input and output arrays are in reverse order, and LINES and
+   TEMP point just past the end of their respective arrays.
+
+   Use a recursive divide-and-conquer algorithm, in the style
+   suggested by Knuth volume 3 (2nd edition), exercise 5.2.4-23.  Use
+   the optimization suggested by exercise 5.2.4-10; this requires room
+   for only 1.5*N lines, rather than the usual 2*N lines.  Knuth
+   writes that this memory optimization was originally published by
+   D. A. Bell, Comp J. 1 (1958), 75.  */
+
+static void
+sequential_sort (struct line *restrict lines, size_t nlines,
+                 struct line *restrict temp, bool to_temp)
+{
+  if (nlines == 2)
+    {
+      /* Declare 'swap' as int, not bool, to work around a bug
+         <http://lists.gnu.org/archive/html/bug-coreutils/2005-10/msg00086.html>
+         in the IBM xlc 6.0.0.0 compiler in 64-bit mode.  */
+      int swap = (0 < compare (&lines[-1], &lines[-2]));
+      if (to_temp)
+        {
+          temp[-1] = lines[-1 - swap];
+          temp[-2] = lines[-2 + swap];
+        }
+      else if (swap)
+        {
+          temp[-1] = lines[-1];
+          lines[-1] = lines[-2];
+          lines[-2] = temp[-1];
+        }
+    }
+  else
+    {
+      size_t nlo = nlines / 2;
+      size_t nhi = nlines - nlo;
+      struct line *lo = lines;
+      struct line *hi = lines - nlo;
+
+      sequential_sort (hi, nhi, temp - (to_temp ? nlo : 0), to_temp);
+      if (1 < nlo)
+        sequential_sort (lo, nlo, temp, !to_temp);
+      else if (!to_temp)
+        temp[-1] = lo[-1];
+
+      struct line *dest;
+      struct line const *sorted_lo;
+      if (to_temp)
+        {
+          dest = temp;
+          sorted_lo = lines;
+        }
+      else
+        {
+          dest = lines;
+          sorted_lo = temp;
+        }
+      mergelines (dest, nlines, sorted_lo);
+    }
+}
+
+static struct merge_node *init_node (struct merge_node *restrict,
+                                     struct merge_node *restrict,
+                                     struct line *, size_t, size_t, bool);
+
+
+/* Create and return a merge tree for NTHREADS threads, sorting NLINES
+   lines, with destination DEST.  */
+static struct merge_node *
+merge_tree_init (size_t nthreads, size_t nlines, struct line *dest)
+{
+  struct merge_node *merge_tree = xmalloc (2 * sizeof *merge_tree * nthreads);
+
+  struct merge_node *root = merge_tree;
+  root->lo = root->hi = root->end_lo = root->end_hi = NULL;
+  root->dest = NULL;
+  root->nlo = root->nhi = nlines;
+  root->parent = NULL;
+  root->level = MERGE_END;
+  root->queued = false;
+  pthread_mutex_init (&root->lock, NULL);
+
+  init_node (root, root + 1, dest, nthreads, nlines, false);
+  return merge_tree;
+}
+
+/* Destroy the merge tree. */
+static void
+merge_tree_destroy (struct merge_node *merge_tree)
+{
+  free (merge_tree);
+}
+
+/* Initialize a merge tree node and its descendants.  The node's
+   parent is PARENT.  The node and its descendants are taken from the
+   array of nodes NODE_POOL.  Their destination starts at DEST; they
+   will consume NTHREADS threads.  The total number of sort lines is
+   TOTAL_LINES.  IS_LO_CHILD is true if the node is the low child of
+   its parent.  */
+
+static struct merge_node *
+init_node (struct merge_node *restrict parent,
+           struct merge_node *restrict node_pool,
+           struct line *dest, size_t nthreads,
+           size_t total_lines, bool is_lo_child)
+{
+  size_t nlines = (is_lo_child ? parent->nlo : parent->nhi);
+  size_t nlo = nlines / 2;
+  size_t nhi = nlines - nlo;
+  struct line *lo = dest - total_lines;
+  struct line *hi = lo - nlo;
+  struct line **parent_end = (is_lo_child ? &parent->end_lo : &parent->end_hi);
+
+  struct merge_node *node = node_pool++;
+  node->lo = node->end_lo = lo;
+  node->hi = node->end_hi = hi;
+  node->dest = parent_end;
+  node->nlo = nlo;
+  node->nhi = nhi;
+  node->parent = parent;
+  node->level = parent->level + 1;
+  node->queued = false;
+  pthread_mutex_init (&node->lock, NULL);
+
+  if (nthreads > 1)
+    {
+      size_t lo_threads = nthreads / 2;
+      size_t hi_threads = nthreads - lo_threads;
+      node->lo_child = node_pool;
+      node_pool = init_node (node, node_pool, lo, lo_threads,
+                             total_lines, true);
+      node->hi_child = node_pool;
+      node_pool = init_node (node, node_pool, hi, hi_threads,
+                             total_lines, false);
+    }
+  else
+    {
+      node->lo_child = NULL;
+      node->hi_child = NULL;
+    }
+  return node_pool;
+}
+
+
+/* Compare two merge nodes A and B for priority.  */
+
+static int
+compare_nodes (void const *a, void const *b)
+{
+  struct merge_node const *nodea = a;
+  struct merge_node const *nodeb = b;
+  if (nodea->level == nodeb->level)
+      return (nodea->nlo + nodea->nhi) < (nodeb->nlo + nodeb->nhi);
+  return nodea->level < nodeb->level;
+}
+
+/* Lock a merge tree NODE.  */
+
+static inline void
+lock_node (struct merge_node *node)
+{
+  pthread_mutex_lock (&node->lock);
+}
+
+/* Unlock a merge tree NODE. */
+
+static inline void
+unlock_node (struct merge_node *node)
+{
+  pthread_mutex_unlock (&node->lock);
+}
+
+/* Destroy merge QUEUE. */
+
+static void
+queue_destroy (struct merge_node_queue *queue)
+{
+  heap_free (queue->priority_queue);
+  pthread_cond_destroy (&queue->cond);
+  pthread_mutex_destroy (&queue->mutex);
+}
+
+/* Initialize merge QUEUE, allocating space suitable for a maximum of
+   NTHREADS threads.  */
+
+static void
+queue_init (struct merge_node_queue *queue, size_t nthreads)
+{
+  /* Though it's highly unlikely all nodes are in the heap at the same
+     time, the heap should accommodate all of them.  Counting a NULL
+     dummy head for the heap, reserve 2 * NTHREADS nodes.  */
+  queue->priority_queue = heap_alloc (compare_nodes, 2 * nthreads);
+  pthread_mutex_init (&queue->mutex, NULL);
+  pthread_cond_init (&queue->cond, NULL);
+}
+
+/* Insert NODE into QUEUE.  The caller either holds a lock on NODE, or
+   does not need to lock NODE.  */
+
+static void
+queue_insert (struct merge_node_queue *queue, struct merge_node *node)
+{
+  pthread_mutex_lock (&queue->mutex);
+  heap_insert (queue->priority_queue, node);
+  node->queued = true;
+  pthread_mutex_unlock (&queue->mutex);
+  pthread_cond_signal (&queue->cond);
+}
+
+/* Pop the top node off the priority QUEUE, lock the node, return it.  */
+
+static struct merge_node *
+queue_pop (struct merge_node_queue *queue)
+{
+  struct merge_node *node;
+  pthread_mutex_lock (&queue->mutex);
+  while (! (node = heap_remove_top (queue->priority_queue)))
+    pthread_cond_wait (&queue->cond, &queue->mutex);
+  pthread_mutex_unlock (&queue->mutex);
+  lock_node (node);
+  node->queued = false;
+  return node;
+}
+
+/* Output LINE to TFP, unless -u is specified and the line compares
+   equal to the previous line.  TEMP_OUTPUT is the name of TFP, or
+   is null if TFP is standard output.
+
+   This function does not save the line for comparison later, so it is
+   appropriate only for internal sort.  */
+
+static void
+write_unique (struct line const *line, FILE *tfp, char const *temp_output)
+{
+  if (unique)
+    {
+      if (saved_line.text && ! compare (line, &saved_line))
+        return;
+      saved_line = *line;
+    }
+
+  write_line (line, tfp, temp_output);
+}
+
+/* Merge the lines currently available to a NODE in the binary
+   merge tree.  Merge a number of lines appropriate for this merge
+   level, assuming TOTAL_LINES is the total number of lines.
+
+   If merging at the top level, send output to TFP.  TEMP_OUTPUT is
+   the name of TFP, or is null if TFP is standard output.  */
+
+static void
+mergelines_node (struct merge_node *restrict node, size_t total_lines,
+                 FILE *tfp, char const *temp_output)
+{
+  struct line *lo_orig = node->lo;
+  struct line *hi_orig = node->hi;
+  size_t to_merge = MAX_MERGE (total_lines, node->level);
+  size_t merged_lo;
+  size_t merged_hi;
+
+  if (node->level > MERGE_ROOT)
+    {
+      /* Merge to destination buffer. */
+      struct line *dest = *node->dest;
+      while (node->lo != node->end_lo && node->hi != node->end_hi && to_merge--)
+        if (compare (node->lo - 1, node->hi - 1) <= 0)
+          *--dest = *--node->lo;
+        else
+          *--dest = *--node->hi;
+
+      merged_lo = lo_orig - node->lo;
+      merged_hi = hi_orig - node->hi;
+
+      if (node->nhi == merged_hi)
+        while (node->lo != node->end_lo && to_merge--)
+          *--dest = *--node->lo;
+      else if (node->nlo == merged_lo)
+        while (node->hi != node->end_hi && to_merge--)
+          *--dest = *--node->hi;
+      *node->dest = dest;
+    }
+  else
+    {
+      /* Merge directly to output. */
+      while (node->lo != node->end_lo && node->hi != node->end_hi && to_merge--)
+        {
+          if (compare (node->lo - 1, node->hi - 1) <= 0)
+            write_unique (--node->lo, tfp, temp_output);
+          else
+            write_unique (--node->hi, tfp, temp_output);
+        }
+
+      merged_lo = lo_orig - node->lo;
+      merged_hi = hi_orig - node->hi;
+
+      if (node->nhi == merged_hi)
+        {
+          while (node->lo != node->end_lo && to_merge--)
+            write_unique (--node->lo, tfp, temp_output);
+        }
+      else if (node->nlo == merged_lo)
+        {
+          while (node->hi != node->end_hi && to_merge--)
+            write_unique (--node->hi, tfp, temp_output);
+        }
+    }
+
+  /* Update NODE. */
+  merged_lo = lo_orig - node->lo;
+  merged_hi = hi_orig - node->hi;
+  node->nlo -= merged_lo;
+  node->nhi -= merged_hi;
+}
+
+/* Into QUEUE, insert NODE if it is not already queued, and if one of
+   NODE's children has available lines and the other either has
+   available lines or has exhausted its lines.  */
+
+static void
+queue_check_insert (struct merge_node_queue *queue, struct merge_node *node)
+{
+  if (! node->queued)
+    {
+      bool lo_avail = (node->lo - node->end_lo) != 0;
+      bool hi_avail = (node->hi - node->end_hi) != 0;
+      if (lo_avail ? hi_avail || ! node->nhi : hi_avail && ! node->nlo)
+        queue_insert (queue, node);
+    }
+}
+
+/* Into QUEUE, insert NODE's parent if the parent can now be worked on.  */
+
+static void
+queue_check_insert_parent (struct merge_node_queue *queue,
+                           struct merge_node *node)
+{
+  if (node->level > MERGE_ROOT)
+    {
+      lock_node (node->parent);
+      queue_check_insert (queue, node->parent);
+      unlock_node (node->parent);
+    }
+  else if (node->nlo + node->nhi == 0)
+    {
+      /* If the MERGE_ROOT NODE has finished merging, insert the
+         MERGE_END node.  */
+      queue_insert (queue, node->parent);
+    }
+}
+
+/* Repeatedly pop QUEUE for a node with lines to merge, and merge at least
+   some of those lines, until the MERGE_END node is popped.
+   TOTAL_LINES is the total number of lines.  If merging at the top
+   level, send output to TFP.  TEMP_OUTPUT is the name of TFP, or is
+   null if TFP is standard output.  */
+
+static void
+merge_loop (struct merge_node_queue *queue,
+            size_t total_lines, FILE *tfp, char const *temp_output)
+{
+  while (1)
+    {
+      struct merge_node *node = queue_pop (queue);
+
+      if (node->level == MERGE_END)
+        {
+          unlock_node (node);
+          /* Reinsert so other threads can pop it. */
+          queue_insert (queue, node);
+          break;
+        }
+      mergelines_node (node, total_lines, tfp, temp_output);
+      queue_check_insert (queue, node);
+      queue_check_insert_parent (queue, node);
+
+      unlock_node (node);
+    }
+}
+
+
+static void sortlines (struct line *restrict, size_t, size_t,
+                       struct merge_node *, struct merge_node_queue *,
+                       FILE *, char const *);
+
+/* Thread arguments for sortlines_thread. */
+
+struct thread_args
+{
+  /* Source, i.e., the array of lines to sort.  This points just past
+     the end of the array.  */
+  struct line *lines;
+
+  /* Number of threads to use.  If 0 or 1, sort single-threaded.  */
+  size_t nthreads;
+
+  /* Number of lines in LINES and DEST.  */
+  size_t const total_lines;
+
+  /* Merge node. Lines from this node and this node's sibling will merged
+     to this node's parent. */
+  struct merge_node *const node;
+
+  /* The priority queue controlling available work for the entire
+     internal sort.  */
+  struct merge_node_queue *const queue;
+
+  /* If at the top level, the file to output to, and the file's name.
+     If the file is standard output, the file's name is null.  */
+  FILE *tfp;
+  char const *output_temp;
+};
+
+/* Like sortlines, except with a signature acceptable to pthread_create.  */
+
+static void *
+sortlines_thread (void *data)
+{
+  struct thread_args const *args = data;
+  sortlines (args->lines, args->nthreads, args->total_lines,
+             args->node, args->queue, args->tfp,
+             args->output_temp);
+  return NULL;
+}
+
+/* Sort lines, possibly in parallel.  The arguments are as in struct
+   thread_args above.
+
+   The algorithm has three phases: node creation, sequential sort,
+   and binary merge.
+
+   During node creation, sortlines recursively visits each node in the
+   binary merge tree and creates a NODE structure corresponding to all the
+   future line merging NODE is responsible for. For each call to
+   sortlines, half the available threads are assigned to each recursive
+   call, until a leaf node having only 1 available thread is reached.
+
+   Each leaf node then performs two sequential sorts, one on each half of
+   the lines it is responsible for. It records in its NODE structure that
+   there are two sorted sublists available to merge from, and inserts its
+   NODE into the priority queue.
+
+   The binary merge phase then begins. Each thread drops into a loop
+   where the thread retrieves a NODE from the priority queue, merges lines
+   available to that NODE, and potentially insert NODE or its parent back
+   into the queue if there are sufficient available lines for them to
+   merge. This continues until all lines at all nodes of the merge tree
+   have been merged. */
+
+static void
+sortlines (struct line *restrict lines, size_t nthreads,
+           size_t total_lines, struct merge_node *node,
+           struct merge_node_queue *queue, FILE *tfp, char const *temp_output)
+{
+  size_t nlines = node->nlo + node->nhi;
+
+  /* Calculate thread arguments. */
+  size_t lo_threads = nthreads / 2;
+  size_t hi_threads = nthreads - lo_threads;
+  pthread_t thread;
+  struct thread_args args = {lines, lo_threads, total_lines,
+                             node->lo_child, queue, tfp, temp_output};
+
+  if (nthreads > 1 && SUBTHREAD_LINES_HEURISTIC <= nlines
+      && pthread_create (&thread, NULL, sortlines_thread, &args) == 0)
+    {
+      sortlines (lines - node->nlo, hi_threads, total_lines,
+                 node->hi_child, queue, tfp, temp_output);
+      pthread_join (thread, NULL);
+    }
+  else
+    {
+      /* Nthreads = 1, this is a leaf NODE, or pthread_create failed.
+         Sort with 1 thread. */
+      size_t nlo = node->nlo;
+      size_t nhi = node->nhi;
+      struct line *temp = lines - total_lines;
+      if (1 < nhi)
+        sequential_sort (lines - nlo, nhi, temp - nlo / 2, false);
+      if (1 < nlo)
+        sequential_sort (lines, nlo, temp, false);
+
+      /* Update merge NODE. No need to lock yet. */
+      node->lo = lines;
+      node->hi = lines - nlo;
+      node->end_lo = lines - nlo;
+      node->end_hi = lines - nlo - nhi;
+
+      queue_insert (queue, node);
+      merge_loop (queue, total_lines, tfp, temp_output);
+    }
+
+  pthread_mutex_destroy (&node->lock);
+}
+
+/* Scan through FILES[NTEMPS .. NFILES-1] looking for files that are
+   the same as OUTFILE.  If found, replace each with the same
+   temporary copy that can be merged into OUTFILE without destroying
+   OUTFILE before it is completely read.  This temporary copy does not
+   count as a merge temp, so don't worry about incrementing NTEMPS in
+   the caller; final cleanup will remove it, not zaptemp.
+
+   This test ensures that an otherwise-erroneous use like
+   "sort -m -o FILE ... FILE ..." copies FILE before writing to it.
+   It's not clear that POSIX requires this nicety.
+   Detect common error cases, but don't try to catch obscure cases like
+   "cat ... FILE ... | sort -m -o FILE"
+   where traditional "sort" doesn't copy the input and where
+   people should know that they're getting into trouble anyway.
+   Catching these obscure cases would slow down performance in
+   common cases.  */
+
+static void
+avoid_trashing_input (struct sortfile *files, size_t ntemps,
+                      size_t nfiles, char const *outfile)
+{
+  size_t i;
+  bool got_outstat = false;
+  struct stat outstat;
+  struct tempnode *tempcopy = NULL;
+
+  for (i = ntemps; i < nfiles; i++)
+    {
+      bool is_stdin = STREQ (files[i].name, "-");
+      bool same;
+      struct stat instat;
+
+      if (outfile && STREQ (outfile, files[i].name) && !is_stdin)
+        same = true;
+      else
+        {
+          if (! got_outstat)
+            {
+              if (fstat (STDOUT_FILENO, &outstat) != 0)
+                break;
+              got_outstat = true;
+            }
+
+          same = (((is_stdin
+                    ? fstat (STDIN_FILENO, &instat)
+                    : stat (files[i].name, &instat))
+                   == 0)
+                  && SAME_INODE (instat, outstat));
+        }
+
+      if (same)
+        {
+          if (! tempcopy)
+            {
+              FILE *tftp;
+              tempcopy = create_temp (&tftp);
+              mergefiles (&files[i], 0, 1, tftp, tempcopy->name);
+            }
+
+          files[i].name = tempcopy->name;
+          files[i].temp = tempcopy;
+        }
+    }
+}
+
+/* Scan the input files to ensure all are accessible.
+   Otherwise exit with a diagnostic.
+
+   Note this will catch common issues with permissions etc.
+   but will fail to notice issues where you can open() but not read(),
+   like when a directory is specified on some systems.
+   Catching these obscure cases could slow down performance in
+   common cases.  */
+
+static void
+check_inputs (char *const *files, size_t nfiles)
+{
+  size_t i;
+  for (i = 0; i < nfiles; i++)
+    {
+      if (STREQ (files[i], "-"))
+        continue;
+
+      if (euidaccess (files[i], R_OK) != 0)
+        die (_("cannot read"), files[i]);
+    }
+}
+
+/* Ensure a specified output file can be created or written to,
+   and point stdout to it.  Do not truncate the file.
+   Exit with a diagnostic on failure.  */
+
+static void
+check_output (char const *outfile)
+{
+  if (outfile)
+    {
+      int outfd = open (outfile, O_WRONLY | O_CREAT | O_BINARY, MODE_RW_UGO);
+      if (outfd < 0)
+        die (_("open failed"), outfile);
+      move_fd_or_die (outfd, STDOUT_FILENO);
+    }
+}
+
+/* Merge the input FILES.  NTEMPS is the number of files at the
+   start of FILES that are temporary; it is zero at the top level.
+   NFILES is the total number of files.  Put the output in
+   OUTPUT_FILE; a null OUTPUT_FILE stands for standard output.  */
+
+static void
+merge (struct sortfile *files, size_t ntemps, size_t nfiles,
+       char const *output_file)
+{
+  while (nmerge < nfiles)
+    {
+      /* Number of input files processed so far.  */
+      size_t in;
+
+      /* Number of output files generated so far.  */
+      size_t out;
+
+      /* nfiles % NMERGE; this counts input files that are left over
+         after all full-sized merges have been done.  */
+      size_t remainder;
+
+      /* Number of easily-available slots at the next loop iteration.  */
+      size_t cheap_slots;
+
+      /* Do as many NMERGE-size merges as possible. In the case that
+         nmerge is bogus, increment by the maximum number of file
+         descriptors allowed.  */
+      for (out = in = 0; nmerge <= nfiles - in; out++)
+        {
+          FILE *tfp;
+          struct tempnode *temp = create_temp (&tfp);
+          size_t num_merged = mergefiles (&files[in], MIN (ntemps, nmerge),
+                                          nmerge, tfp, temp->name);
+          ntemps -= MIN (ntemps, num_merged);
+          files[out].name = temp->name;
+          files[out].temp = temp;
+          in += num_merged;
+        }
+
+      remainder = nfiles - in;
+      cheap_slots = nmerge - out % nmerge;
+
+      if (cheap_slots < remainder)
+        {
+          /* So many files remain that they can't all be put into the last
+             NMERGE-sized output window.  Do one more merge.  Merge as few
+             files as possible, to avoid needless I/O.  */
+          size_t nshortmerge = remainder - cheap_slots + 1;
+          FILE *tfp;
+          struct tempnode *temp = create_temp (&tfp);
+          size_t num_merged = mergefiles (&files[in], MIN (ntemps, nshortmerge),
+                                          nshortmerge, tfp, temp->name);
+          ntemps -= MIN (ntemps, num_merged);
+          files[out].name = temp->name;
+          files[out++].temp = temp;
+          in += num_merged;
+        }
+
+      /* Put the remaining input files into the last NMERGE-sized output
+         window, so they will be merged in the next pass.  */
+      memmove (&files[out], &files[in], (nfiles - in) * sizeof *files);
+      ntemps += out;
+      nfiles -= in - out;
+    }
+
+  avoid_trashing_input (files, ntemps, nfiles, output_file);
+
+  /* We aren't guaranteed that this final mergefiles will work, therefore we
+     try to merge into the output, and then merge as much as we can into a
+     temp file if we can't. Repeat.  */
+
+  while (true)
+    {
+      /* Merge directly into the output file if possible.  */
+      FILE **fps;
+      size_t nopened = open_input_files (files, nfiles, &fps);
+
+      if (nopened == nfiles)
+        {
+          FILE *ofp = stream_open (output_file, "w");
+          if (ofp)
+            {
+              mergefps (files, ntemps, nfiles, ofp, output_file, fps);
+              break;
+            }
+          if (errno != EMFILE || nopened <= 2)
+            die (_("open failed"), output_file);
+        }
+      else if (nopened <= 2)
+        die (_("open failed"), files[nopened].name);
+
+      /* We ran out of file descriptors.  Close one of the input
+         files, to gain a file descriptor.  Then create a temporary
+         file with our spare file descriptor.  Retry if that failed
+         (e.g., some other process could open a file between the time
+         we closed and tried to create).  */
+      FILE *tfp;
+      struct tempnode *temp;
+      do
+        {
+          nopened--;
+          xfclose (fps[nopened], files[nopened].name);
+          temp = maybe_create_temp (&tfp, ! (nopened <= 2));
+        }
+      while (!temp);
+
+      /* Merge into the newly allocated temporary.  */
+      mergefps (&files[0], MIN (ntemps, nopened), nopened, tfp, temp->name,
+                fps);
+      ntemps -= MIN (ntemps, nopened);
+      files[0].name = temp->name;
+      files[0].temp = temp;
+
+      memmove (&files[1], &files[nopened], (nfiles - nopened) * sizeof *files);
+      ntemps++;
+      nfiles -= nopened - 1;
+    }
+}
+
+/* Sort NFILES FILES onto OUTPUT_FILE.  Use at most NTHREADS threads.  */
+
+static void
+sort (char *const *files, size_t nfiles, char const *output_file,
+      size_t nthreads)
+{
+  struct buffer buf;
+  IF_LINT (buf.buf = NULL);
+  size_t ntemps = 0;
+  bool output_file_created = false;
+
+  buf.alloc = 0;
+
+  while (nfiles)
+    {
+      char const *temp_output;
+      char const *file = *files;
+      FILE *fp = xfopen (file, "r");
+      FILE *tfp;
+
+      size_t bytes_per_line;
+      if (nthreads > 1)
+        {
+          /* Get log P. */
+          size_t tmp = 1;
+          size_t mult = 1;
+          while (tmp < nthreads)
+            {
+              tmp *= 2;
+              mult++;
+            }
+          bytes_per_line = (mult * sizeof (struct line));
+        }
+      else
+        bytes_per_line = sizeof (struct line) * 3 / 2;
+
+      if (! buf.alloc)
+        initbuf (&buf, bytes_per_line,
+                 sort_buffer_size (&fp, 1, files, nfiles, bytes_per_line));
+      buf.eof = false;
+      files++;
+      nfiles--;
+
+      while (fillbuf (&buf, fp, file))
+        {
+          struct line *line;
+
+          if (buf.eof && nfiles
+              && (bytes_per_line + 1
+                  < (buf.alloc - buf.used - bytes_per_line * buf.nlines)))
+            {
+              /* End of file, but there is more input and buffer room.
+                 Concatenate the next input file; this is faster in
+                 the usual case.  */
+              buf.left = buf.used;
+              break;
+            }
+
+          saved_line.text = NULL;
+          line = buffer_linelim (&buf);
+          if (buf.eof && !nfiles && !ntemps && !buf.left)
+            {
+              xfclose (fp, file);
+              tfp = xfopen (output_file, "w");
+              temp_output = output_file;
+              output_file_created = true;
+            }
+          else
+            {
+              ++ntemps;
+              temp_output = create_temp (&tfp)->name;
+            }
+          if (1 < buf.nlines)
+            {
+              struct merge_node_queue queue;
+              queue_init (&queue, nthreads);
+              struct merge_node *merge_tree =
+                merge_tree_init (nthreads, buf.nlines, line);
+              struct merge_node *root = merge_tree + 1;
+
+              sortlines (line, nthreads, buf.nlines, root,
+                         &queue, tfp, temp_output);
+              queue_destroy (&queue);
+              pthread_mutex_destroy (&root->lock);
+              merge_tree_destroy (merge_tree);
+            }
+          else
+            write_unique (line - 1, tfp, temp_output);
+
+          xfclose (tfp, temp_output);
+
+          if (output_file_created)
+            goto finish;
+        }
+      xfclose (fp, file);
+    }
+
+ finish:
+  free (buf.buf);
+
+  if (! output_file_created)
+    {
+      size_t i;
+      struct tempnode *node = temphead;
+      struct sortfile *tempfiles = xnmalloc (ntemps, sizeof *tempfiles);
+      for (i = 0; node; i++)
+        {
+          tempfiles[i].name = node->name;
+          tempfiles[i].temp = node;
+          node = node->next;
+        }
+      merge (tempfiles, ntemps, ntemps, output_file);
+      free (tempfiles);
+    }
+
+  reap_all ();
+}
+
+/* Insert a malloc'd copy of key KEY_ARG at the end of the key list.  */
+
+static void
+insertkey (struct keyfield *key_arg)
+{
+  struct keyfield **p;
+  struct keyfield *key = xmemdup (key_arg, sizeof *key);
+
+  for (p = &keylist; *p; p = &(*p)->next)
+    continue;
+  *p = key;
+  key->next = NULL;
+}
+
+/* Report a bad field specification SPEC, with extra info MSGID.  */
+
+static void badfieldspec (char const *, char const *)
+     ATTRIBUTE_NORETURN;
+static void
+badfieldspec (char const *spec, char const *msgid)
+{
+  error (SORT_FAILURE, 0, _("%s: invalid field specification %s"),
+         _(msgid), quote (spec));
+  abort ();
+}
+
+/* Report incompatible options.  */
+
+static void incompatible_options (char const *) ATTRIBUTE_NORETURN;
+static void
+incompatible_options (char const *opts)
+{
+  error (SORT_FAILURE, 0, _("options '-%s' are incompatible"), opts);
+  abort ();
+}
+
+/* Check compatibility of ordering options.  */
+
+static void
+check_ordering_compatibility (void)
+{
+  struct keyfield *key;
+
+  for (key = keylist; key; key = key->next)
+    if (1 < (key->numeric + key->general_numeric + key->human_numeric
+             + key->month + (key->version | key->random | !!key->ignore)))
+      {
+        /* The following is too big, but guaranteed to be "big enough".  */
+        char opts[sizeof short_options];
+        /* Clear flags we're not interested in.  */
+        key->skipsblanks = key->skipeblanks = key->reverse = false;
+        key_to_opts (key, opts);
+        incompatible_options (opts);
+      }
+}
+
+/* Parse the leading integer in STRING and store the resulting value
+   (which must fit into size_t) into *VAL.  Return the address of the
+   suffix after the integer.  If the value is too large, silently
+   substitute SIZE_MAX.  If MSGID is NULL, return NULL after
+   failure; otherwise, report MSGID and exit on failure.  */
+
+static char const *
+parse_field_count (char const *string, size_t *val, char const *msgid)
+{
+  char *suffix;
+  uintmax_t n;
+
+  switch (xstrtoumax (string, &suffix, 10, &n, ""))
+    {
+    case LONGINT_OK:
+    case LONGINT_INVALID_SUFFIX_CHAR:
+      *val = n;
+      if (*val == n)
+        break;
+      /* Fall through.  */
+    case LONGINT_OVERFLOW:
+    case LONGINT_OVERFLOW | LONGINT_INVALID_SUFFIX_CHAR:
+      *val = SIZE_MAX;
+      break;
+
+    case LONGINT_INVALID:
+      if (msgid)
+        error (SORT_FAILURE, 0, _("%s: invalid count at start of %s"),
+               _(msgid), quote (string));
+      return NULL;
+    }
+
+  return suffix;
+}
+
+/* Handle interrupts and hangups. */
+
+static void
+sighandler (int sig)
+{
+  if (! SA_NOCLDSTOP)
+    signal (sig, SIG_IGN);
+
+  cleanup ();
+
+  signal (sig, SIG_DFL);
+  raise (sig);
+}
+
+/* Set the ordering options for KEY specified in S.
+   Return the address of the first character in S that
+   is not a valid ordering option.
+   BLANKTYPE is the kind of blanks that 'b' should skip. */
+
+static char *
+set_ordering (char const *s, struct keyfield *key, enum blanktype blanktype)
+{
+  while (*s)
+    {
+      switch (*s)
+        {
+        case 'b':
+          if (blanktype == bl_start || blanktype == bl_both)
+            key->skipsblanks = true;
+          if (blanktype == bl_end || blanktype == bl_both)
+            key->skipeblanks = true;
+          break;
+        case 'd':
+          key->ignore = nondictionary;
+          break;
+        case 'f':
+          key->translate = fold_toupper;
+          break;
+        case 'g':
+          key->general_numeric = true;
+          break;
+        case 'h':
+          key->human_numeric = true;
+          break;
+        case 'i':
+          /* Option order should not matter, so don't let -i override
+             -d.  -d implies -i, but -i does not imply -d.  */
+          if (! key->ignore)
+            key->ignore = nonprinting;
+          break;
+        case 'M':
+          key->month = true;
+          break;
+        case 'n':
+          key->numeric = true;
+          break;
+        case 'R':
+          key->random = true;
+          break;
+        case 'r':
+          key->reverse = true;
+          break;
+        case 'V':
+          key->version = true;
+          break;
+        default:
+          return (char *) s;
+        }
+      ++s;
+    }
+  return (char *) s;
+}
+
+/* Initialize KEY.  */
+
+static struct keyfield *
+key_init (struct keyfield *key)
+{
+  memset (key, 0, sizeof *key);
+  key->eword = SIZE_MAX;
+  return key;
+}
+
+int
+main (int argc, char **argv)
+{
+  struct keyfield *key;
+  struct keyfield key_buf;
+  struct keyfield gkey;
+  bool gkey_only = false;
+  char const *s;
+  int c = 0;
+  char checkonly = 0;
+  bool mergeonly = false;
+  char *random_source = NULL;
+  bool need_random = false;
+  size_t nthreads = 0;
+  size_t nfiles = 0;
+  bool posixly_correct = (getenv ("POSIXLY_CORRECT") != NULL);
+  bool obsolete_usage = (posix2_version () < 200112);
+  char **files;
+  char *files_from = NULL;
+  struct Tokens tok;
+  char const *outfile = NULL;
+
+  initialize_main (&argc, &argv);
+  set_program_name (argv[0]);
+  setlocale (LC_ALL, "");
+  bindtextdomain (PACKAGE, LOCALEDIR);
+  textdomain (PACKAGE);
+
+  initialize_exit_failure (SORT_FAILURE);
+
+  hard_LC_COLLATE = hard_locale (LC_COLLATE);
+#if HAVE_NL_LANGINFO
+  hard_LC_TIME = hard_locale (LC_TIME);
+#endif
+
+  /* Get locale's representation of the decimal point.  */
+  {
+    struct lconv const *locale = localeconv ();
+
+    /* If the locale doesn't define a decimal point, or if the decimal
+       point is multibyte, use the C locale's decimal point.  FIXME:
+       add support for multibyte decimal points.  */
+    decimal_point = to_uchar (locale->decimal_point[0]);
+    if (! decimal_point || locale->decimal_point[1])
+      decimal_point = '.';
+
+    /* FIXME: add support for multibyte thousands separators.  */
+    thousands_sep = to_uchar (*locale->thousands_sep);
+    if (! thousands_sep || locale->thousands_sep[1])
+      thousands_sep = -1;
+  }
+
+  have_read_stdin = false;
+  inittables ();
+
+  {
+    size_t i;
+    static int const sig[] =
+      {
+        /* The usual suspects.  */
+        SIGALRM, SIGHUP, SIGINT, SIGPIPE, SIGQUIT, SIGTERM,
+#ifdef SIGPOLL
+        SIGPOLL,
+#endif
+#ifdef SIGPROF
+        SIGPROF,
+#endif
+#ifdef SIGVTALRM
+        SIGVTALRM,
+#endif
+#ifdef SIGXCPU
+        SIGXCPU,
+#endif
+#ifdef SIGXFSZ
+        SIGXFSZ,
+#endif
+      };
+    enum { nsigs = ARRAY_CARDINALITY (sig) };
+
+#if SA_NOCLDSTOP
+    struct sigaction act;
+
+    sigemptyset (&caught_signals);
+    for (i = 0; i < nsigs; i++)
+      {
+        sigaction (sig[i], NULL, &act);
+        if (act.sa_handler != SIG_IGN)
+          sigaddset (&caught_signals, sig[i]);
+      }
+
+    act.sa_handler = sighandler;
+    act.sa_mask = caught_signals;
+    act.sa_flags = 0;
+
+    for (i = 0; i < nsigs; i++)
+      if (sigismember (&caught_signals, sig[i]))
+        sigaction (sig[i], &act, NULL);
+#else
+    for (i = 0; i < nsigs; i++)
+      if (signal (sig[i], SIG_IGN) != SIG_IGN)
+        {
+          signal (sig[i], sighandler);
+          siginterrupt (sig[i], 1);
+        }
+#endif
+  }
+  signal (SIGCHLD, SIG_DFL); /* Don't inherit CHLD handling from parent.  */
+
+  /* The signal mask is known, so it is safe to invoke exit_cleanup.  */
+  atexit (exit_cleanup);
+
+  key_init (&gkey);
+  gkey.sword = SIZE_MAX;
+
+  files = xnmalloc (argc, sizeof *files);
+
+  while (true)
+    {
+      /* Parse an operand as a file after "--" was seen; or if
+         pedantic and a file was seen, unless the POSIX version
+         predates 1003.1-2001 and -c was not seen and the operand is
+         "-o FILE" or "-oFILE".  */
+      int oi = -1;
+
+      if (c == -1
+          || (posixly_correct && nfiles != 0
+              && ! (obsolete_usage
+                    && ! checkonly
+                    && optind != argc
+                    && argv[optind][0] == '-' && argv[optind][1] == 'o'
+                    && (argv[optind][2] || optind + 1 != argc)))
+          || ((c = getopt_long (argc, argv, short_options,
+                                long_options, &oi))
+              == -1))
+        {
+          if (argc <= optind)
+            break;
+          files[nfiles++] = argv[optind++];
+        }
+      else switch (c)
+        {
+        case 1:
+          key = NULL;
+          if (optarg[0] == '+')
+            {
+              bool minus_pos_usage = (optind != argc && argv[optind][0] == '-'
+                                      && ISDIGIT (argv[optind][1]));
+              obsolete_usage |= minus_pos_usage && !posixly_correct;
+              if (obsolete_usage)
+                {
+                  /* Treat +POS1 [-POS2] as a key if possible; but silently
+                     treat an operand as a file if it is not a valid +POS1.  */
+                  key = key_init (&key_buf);
+                  s = parse_field_count (optarg + 1, &key->sword, NULL);
+                  if (s && *s == '.')
+                    s = parse_field_count (s + 1, &key->schar, NULL);
+                  if (! (key->sword || key->schar))
+                    key->sword = SIZE_MAX;
+                  if (! s || *set_ordering (s, key, bl_start))
+                    key = NULL;
+                  else
+                    {
+                      if (minus_pos_usage)
+                        {
+                          char const *optarg1 = argv[optind++];
+                          s = parse_field_count (optarg1 + 1, &key->eword,
+                                             N_("invalid number after '-'"));
+                          /* When called with a non-NULL message ID,
+                             parse_field_count cannot return NULL.  Tell static
+                             analysis tools that dereferencing S is safe.  */
+                          assert (s);
+                          if (*s == '.')
+                            s = parse_field_count (s + 1, &key->echar,
+                                               N_("invalid number after '.'"));
+                          if (!key->echar && key->eword)
+                            {
+                              /* obsolescent syntax +A.x -B.y is equivalent to:
+                                   -k A+1.x+1,B.y   (when y = 0)
+                                   -k A+1.x+1,B+1.y (when y > 0)
+                                 So eword is decremented as in the -k case
+                                 only when the end field (B) is specified and
+                                 echar (y) is 0.  */
+                              key->eword--;
+                            }
+                          if (*set_ordering (s, key, bl_end))
+                            badfieldspec (optarg1,
+                                      N_("stray character in field spec"));
+                        }
+                      key->obsolete_used = true;
+                      insertkey (key);
+                    }
+                }
+            }
+          if (! key)
+            files[nfiles++] = optarg;
+          break;
+
+        case SORT_OPTION:
+          c = XARGMATCH ("--sort", optarg, sort_args, sort_types);
+          /* Fall through. */
+        case 'b':
+        case 'd':
+        case 'f':
+        case 'g':
+        case 'h':
+        case 'i':
+        case 'M':
+        case 'n':
+        case 'r':
+        case 'R':
+        case 'V':
+          {
+            char str[2];
+            str[0] = c;
+            str[1] = '\0';
+            set_ordering (str, &gkey, bl_both);
+          }
+          break;
+
+        case CHECK_OPTION:
+          c = (optarg
+               ? XARGMATCH ("--check", optarg, check_args, check_types)
+               : 'c');
+          /* Fall through.  */
+        case 'c':
+        case 'C':
+          if (checkonly && checkonly != c)
+            incompatible_options ("cC");
+          checkonly = c;
+          break;
+
+        case COMPRESS_PROGRAM_OPTION:
+          if (compress_program && !STREQ (compress_program, optarg))
+            error (SORT_FAILURE, 0, _("multiple compress programs specified"));
+          compress_program = optarg;
+          break;
+
+        case DEBUG_PROGRAM_OPTION:
+          debug = true;
+          break;
+
+        case FILES0_FROM_OPTION:
+          files_from = optarg;
+          break;
+
+        case 'k':
+          key = key_init (&key_buf);
+
+          /* Get POS1. */
+          s = parse_field_count (optarg, &key->sword,
+                                 N_("invalid number at field start"));
+          if (! key->sword--)
+            {
+              /* Provoke with 'sort -k0' */
+              badfieldspec (optarg, N_("field number is zero"));
+            }
+          if (*s == '.')
+            {
+              s = parse_field_count (s + 1, &key->schar,
+                                     N_("invalid number after '.'"));
+              if (! key->schar--)
+                {
+                  /* Provoke with 'sort -k1.0' */
+                  badfieldspec (optarg, N_("character offset is zero"));
+                }
+            }
+          if (! (key->sword || key->schar))
+            key->sword = SIZE_MAX;
+          s = set_ordering (s, key, bl_start);
+          if (*s != ',')
+            {
+              key->eword = SIZE_MAX;
+              key->echar = 0;
+            }
+          else
+            {
+              /* Get POS2. */
+              s = parse_field_count (s + 1, &key->eword,
+                                     N_("invalid number after ','"));
+              if (! key->eword--)
+                {
+                  /* Provoke with 'sort -k1,0' */
+                  badfieldspec (optarg, N_("field number is zero"));
+                }
+              if (*s == '.')
+                {
+                  s = parse_field_count (s + 1, &key->echar,
+                                         N_("invalid number after '.'"));
+                }
+              s = set_ordering (s, key, bl_end);
+            }
+          if (*s)
+            badfieldspec (optarg, N_("stray character in field spec"));
+          insertkey (key);
+          break;
+
+        case 'm':
+          mergeonly = true;
+          break;
+
+        case NMERGE_OPTION:
+          specify_nmerge (oi, c, optarg);
+          break;
+
+        case 'o':
+          if (outfile && !STREQ (outfile, optarg))
+            error (SORT_FAILURE, 0, _("multiple output files specified"));
+          outfile = optarg;
+          break;
+
+        case RANDOM_SOURCE_OPTION:
+          if (random_source && !STREQ (random_source, optarg))
+            error (SORT_FAILURE, 0, _("multiple random sources specified"));
+          random_source = optarg;
+          break;
+
+        case 's':
+          stable = true;
+          break;
+
+        case 'S':
+          specify_sort_size (oi, c, optarg);
+          break;
+
+        case 't':
+          {
+            char newtab = optarg[0];
+            if (! newtab)
+              error (SORT_FAILURE, 0, _("empty tab"));
+            if (optarg[1])
+              {
+                if (STREQ (optarg, "\\0"))
+                  newtab = '\0';
+                else
+                  {
+                    /* Provoke with 'sort -txx'.  Complain about
+                       "multi-character tab" instead of "multibyte tab", so
+                       that the diagnostic's wording does not need to be
+                       changed once multibyte characters are supported.  */
+                    error (SORT_FAILURE, 0, _("multi-character tab %s"),
+                           quote (optarg));
+                  }
+              }
+            if (tab != TAB_DEFAULT && tab != newtab)
+              error (SORT_FAILURE, 0, _("incompatible tabs"));
+            tab = newtab;
+          }
+          break;
+
+        case 'T':
+          add_temp_dir (optarg);
+          break;
+
+        case PARALLEL_OPTION:
+          nthreads = specify_nthreads (oi, c, optarg);
+          break;
+
+        case 'u':
+          unique = true;
+          break;
+
+        case 'y':
+          /* Accept and ignore e.g. -y0 for compatibility with Solaris 2.x
+             through Solaris 7.  It is also accepted by many non-Solaris
+             "sort" implementations, e.g., AIX 5.2, HP-UX 11i v2, IRIX 6.5.
+             -y is marked as obsolete starting with Solaris 8 (1999), but is
+             still accepted as of Solaris 10 prerelease (2004).
+
+             Solaris 2.5.1 "sort -y 100" reads the input file "100", but
+             emulate Solaris 8 and 9 "sort -y 100" which ignores the "100",
+             and which in general ignores the argument after "-y" if it
+             consists entirely of digits (it can even be empty).  */
+          if (optarg == argv[optind - 1])
+            {
+              char const *p;
+              for (p = optarg; ISDIGIT (*p); p++)
+                continue;
+              optind -= (*p != '\0');
+            }
+          break;
+
+        case 'z':
+          eolchar = 0;
+          break;
+
+        case_GETOPT_HELP_CHAR;
+
+        case_GETOPT_VERSION_CHAR (PROGRAM_NAME, AUTHORS);
+
+        default:
+          usage (SORT_FAILURE);
+        }
+    }
+
+  if (files_from)
+    {
+      FILE *stream;
+
+      /* When using --files0-from=F, you may not specify any files
+         on the command-line.  */
+      if (nfiles)
+        {
+          error (0, 0, _("extra operand %s"), quote (files[0]));
+          fprintf (stderr, "%s\n",
+                   _("file operands cannot be combined with --files0-from"));
+          usage (SORT_FAILURE);
+        }
+
+      if (STREQ (files_from, "-"))
+        stream = stdin;
+      else
+        {
+          stream = fopen (files_from, "r");
+          if (stream == NULL)
+            error (SORT_FAILURE, errno, _("cannot open %s for reading"),
+                   quote (files_from));
+        }
+
+      readtokens0_init (&tok);
+
+      if (! readtokens0 (stream, &tok) || fclose (stream) != 0)
+        error (SORT_FAILURE, 0, _("cannot read file names from %s"),
+               quote (files_from));
+
+      if (tok.n_tok)
+        {
+          size_t i;
+          free (files);
+          files = tok.tok;
+          nfiles = tok.n_tok;
+          for (i = 0; i < nfiles; i++)
+            {
+              if (STREQ (files[i], "-"))
+                error (SORT_FAILURE, 0, _("when reading file names from stdin, "
+                                          "no file name of %s allowed"),
+                       quote (files[i]));
+              else if (files[i][0] == '\0')
+                {
+                  /* Using the standard 'filename:line-number:' prefix here is
+                     not totally appropriate, since NUL is the separator,
+                     not NL, but it might be better than nothing.  */
+                  unsigned long int file_number = i + 1;
+                  error (SORT_FAILURE, 0,
+                         _("%s:%lu: invalid zero-length file name"),
+                         quotearg_colon (files_from), file_number);
+                }
+            }
+        }
+      else
+        error (SORT_FAILURE, 0, _("no input from %s"),
+               quote (files_from));
+    }
+
+  /* Inheritance of global options to individual keys. */
+  for (key = keylist; key; key = key->next)
+    {
+      if (default_key_compare (key) && !key->reverse)
+        {
+          key->ignore = gkey.ignore;
+          key->translate = gkey.translate;
+          key->skipsblanks = gkey.skipsblanks;
+          key->skipeblanks = gkey.skipeblanks;
+          key->month = gkey.month;
+          key->numeric = gkey.numeric;
+          key->general_numeric = gkey.general_numeric;
+          key->human_numeric = gkey.human_numeric;
+          key->version = gkey.version;
+          key->random = gkey.random;
+          key->reverse = gkey.reverse;
+        }
+
+      need_random |= key->random;
+    }
+
+  if (!keylist && !default_key_compare (&gkey))
+    {
+      gkey_only = true;
+      insertkey (&gkey);
+      need_random |= gkey.random;
+    }
+
+  check_ordering_compatibility ();
+
+  if (debug)
+    {
+      if (checkonly || outfile)
+        {
+          static char opts[] = "X --debug";
+          opts[0] = (checkonly ? checkonly : 'o');
+          incompatible_options (opts);
+        }
+
+      /* Always output the locale in debug mode, since this
+         is such a common source of confusion.  */
+      if (hard_LC_COLLATE)
+        error (0, 0, _("using %s sorting rules"),
+               quote (setlocale (LC_COLLATE, NULL)));
+      else
+        error (0, 0, _("using simple byte comparison"));
+      key_warnings (&gkey, gkey_only);
+    }
+
+  reverse = gkey.reverse;
+
+  if (need_random)
+    random_md5_state_init (random_source);
+
+  if (temp_dir_count == 0)
+    {
+      char const *tmp_dir = getenv ("TMPDIR");
+      add_temp_dir (tmp_dir ? tmp_dir : DEFAULT_TMPDIR);
+    }
+
+  if (nfiles == 0)
+    {
+      static char *minus = (char *) "-";
+      nfiles = 1;
+      free (files);
+      files = &minus;
+    }
+
+  /* Need to re-check that we meet the minimum requirement for memory
+     usage with the final value for NMERGE. */
+  if (0 < sort_size)
+    sort_size = MAX (sort_size, MIN_SORT_SIZE);
+
+  if (checkonly)
+    {
+      if (nfiles > 1)
+        error (SORT_FAILURE, 0, _("extra operand %s not allowed with -%c"),
+               quote (files[1]), checkonly);
+
+      if (outfile)
+        {
+          static char opts[] = {0, 'o', 0};
+          opts[0] = checkonly;
+          incompatible_options (opts);
+        }
+
+      /* POSIX requires that sort return 1 IFF invoked with -c or -C and the
+         input is not properly sorted.  */
+      exit (check (files[0], checkonly) ? EXIT_SUCCESS : SORT_OUT_OF_ORDER);
+    }
+
+  /* Check all inputs are accessible, or exit immediately.  */
+  check_inputs (files, nfiles);
+
+  /* Check output is writable, or exit immediately.  */
+  check_output (outfile);
+
+  if (mergeonly)
+    {
+      struct sortfile *sortfiles = xcalloc (nfiles, sizeof *sortfiles);
+      size_t i;
+
+      for (i = 0; i < nfiles; ++i)
+        sortfiles[i].name = files[i];
+
+      merge (sortfiles, 0, nfiles, outfile);
+      IF_LINT (free (sortfiles));
+    }
+  else
+    {
+      if (!nthreads)
+        {
+          unsigned long int np = num_processors (NPROC_CURRENT_OVERRIDABLE);
+          nthreads = MIN (np, DEFAULT_MAX_THREADS);
+        }
+
+      /* Avoid integer overflow later.  */
+      size_t nthreads_max = SIZE_MAX / (2 * sizeof (struct merge_node));
+      nthreads = MIN (nthreads, nthreads_max);
+
+      sort (files, nfiles, outfile, nthreads);
+    }
+
+  if (have_read_stdin && fclose (stdin) == EOF)
+    die (_("close failed"), "-");
+
+  exit (EXIT_SUCCESS);
+}
diff -Naur coreutils-8.19.orig/src/unexpand.c coreutils-8.19/src/unexpand.c
--- coreutils-8.19.orig/src/unexpand.c	2012-07-21 09:54:31.000000000 -0500
+++ coreutils-8.19/src/unexpand.c	2012-08-20 21:50:40.000000000 -0500
@@ -38,12 +38,29 @@
 #include <stdio.h>
 #include <getopt.h>
 #include <sys/types.h>
+
+/* Get mbstate_t, mbrtowc(), wcwidth(). */
+#if HAVE_WCHAR_H
+# include <wchar.h>
+#endif
+
 #include "system.h"
 #include "error.h"
 #include "fadvise.h"
 #include "quote.h"
 #include "xstrndup.h"
 
+/* MB_LEN_MAX is incorrectly defined to be 1 in at least one GCC
+      installation; work around this configuration error.  */
+#if !defined MB_LEN_MAX || MB_LEN_MAX < 2
+# define MB_LEN_MAX 16
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HAVE_MBRTOWC && defined mbstate_t
+# define mbrtowc(pwc, s, n, ps) (mbrtowc) (pwc, s, n, 0)
+#endif
+
 /* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "unexpand"
 
@@ -103,6 +120,208 @@
   {NULL, 0, NULL, 0}
 };
 
+static FILE *next_file (FILE *fp);
+
+#if HAVE_MBRTOWC
+static void
+unexpand_multibyte (void)
+{
+  FILE *fp;			/* Input stream. */
+  mbstate_t i_state;		/* Current shift state of the input stream. */
+  mbstate_t i_state_bak;	/* Back up the I_STATE. */
+  mbstate_t o_state;		/* Current shift state of the output stream. */
+  char buf[MB_LEN_MAX + BUFSIZ];  /* For spooling a read byte sequence. */
+  char *bufpos = buf;			/* Next read position of BUF. */
+  size_t buflen = 0;		/* The length of the byte sequence in buf. */
+  wint_t wc;			/* A gotten wide character. */
+  size_t mblength;		/* The byte size of a multibyte character
+				   which shows as same character as WC. */
+
+  /* Index in `tab_list' of next tabstop: */
+  int tab_index = 0;		/* For calculating width of pending tabs. */
+  int print_tab_index = 0;	/* For printing as many tabs as possible. */
+  unsigned int column = 0;	/* Column on screen of next char. */
+  int next_tab_column;		/* Column the next tab stop is on. */
+  int convert = 1;		/* If nonzero, perform translations. */
+  unsigned int pending = 0;	/* Pending columns of blanks. */
+
+  fp = next_file ((FILE *) NULL);
+  if (fp == NULL)
+    return;
+
+  memset (&o_state, '\0', sizeof(mbstate_t));
+  memset (&i_state, '\0', sizeof(mbstate_t));
+
+  for (;;)
+    {
+      if (buflen < MB_LEN_MAX && !feof(fp) && !ferror(fp))
+	{
+	  memmove (buf, bufpos, buflen);
+	  buflen += fread (buf + buflen, sizeof(char), BUFSIZ, fp);
+	  bufpos = buf;
+	}
+
+      /* Get a wide character. */
+      if (buflen < 1)
+	{
+	  mblength = 1;
+	  wc = WEOF;
+	}
+      else
+	{
+	  i_state_bak = i_state;
+	  mblength = mbrtowc ((wchar_t *)&wc, bufpos, buflen, &i_state);
+	}
+
+      if (mblength == (size_t)-1 || mblength == (size_t)-2)
+	{
+	  i_state = i_state_bak;
+	  wc = L'\0';
+	}
+
+      if (wc == L' ' && convert && column < INT_MAX)
+	{
+	  ++pending;
+	  ++column;
+	}
+      else if (wc == L'\t' && convert)
+	{
+	  if (tab_size == 0)
+	    {
+	      /* Do not let tab_index == first_free_tab;
+		 stop when it is 1 less. */
+	      while (tab_index < first_free_tab - 1
+		  && column >= tab_list[tab_index])
+		tab_index++;
+	      next_tab_column = tab_list[tab_index];
+	      if (tab_index < first_free_tab - 1)
+		tab_index++;
+	      if (column >= next_tab_column)
+		{
+		  convert = 0;	/* Ran out of tab stops. */
+		  goto flush_pend_mb;
+		}
+	    }
+	  else
+	    {
+	      next_tab_column = column + tab_size - column % tab_size;
+	    }
+	  pending += next_tab_column - column;
+	  column = next_tab_column;
+	}
+      else
+	{
+flush_pend_mb:
+	  /* Flush pending spaces.  Print as many tabs as possible,
+	     then print the rest as spaces. */
+	  if (pending == 1)
+	    {
+	      putchar (' ');
+	      pending = 0;
+	    }
+	  column -= pending;
+	  while (pending > 0)
+	    {
+	      if (tab_size == 0)
+		{
+		  /* Do not let print_tab_index == first_free_tab;
+		     stop when it is 1 less. */
+		  while (print_tab_index < first_free_tab - 1
+		      && column >= tab_list[print_tab_index])
+		    print_tab_index++;
+		  next_tab_column = tab_list[print_tab_index];
+		  if (print_tab_index < first_free_tab - 1)
+		    print_tab_index++;
+		}
+	      else
+		{
+		  next_tab_column =
+		    column + tab_size - column % tab_size;
+		}
+	      if (next_tab_column - column <= pending)
+		{
+		  putchar ('\t');
+		  pending -= next_tab_column - column;
+		  column = next_tab_column;
+		}
+	      else
+		{
+		  --print_tab_index;
+		  column += pending;
+		  while (pending != 0)
+		    {
+		      putchar (' ');
+		      pending--;
+		    }
+		}
+	    }
+
+	  if (wc == WEOF)
+	    {
+	      fp = next_file (fp);
+	      if (fp == NULL)
+		break;          /* No more files. */
+	      else
+		{
+		  memset (&i_state, '\0', sizeof(mbstate_t));
+		  continue;
+		}
+	    }
+
+	  if (mblength == (size_t)-1 || mblength == (size_t)-2)
+	    {
+	      if (convert)
+		{
+		  ++column;
+		  if (convert_entire_line == 0)
+		    convert = 0;
+		}
+	      mblength = 1;
+	      putchar (buf[0]);
+	    }
+	  else if (mblength == 0)
+	    {
+	      if (convert && convert_entire_line == 0)
+		convert = 0;
+	      mblength = 1;
+	      putchar ('\0');
+	    }
+	  else
+	    {
+	      if (convert)
+		{
+		  if (wc == L'\b')
+		    {
+		      if (column > 0)
+			--column;
+		    }
+		  else
+		    {
+		      int width;            /* The width of WC. */
+
+		      width = wcwidth (wc);
+		      column += (width > 0) ? width : 0;
+		      if (convert_entire_line == 0)
+			convert = 0;
+		    }
+		}
+
+	      if (wc == L'\n')
+		{
+		  tab_index = print_tab_index = 0;
+		  column = pending = 0;
+		  convert = 1;
+		}
+	      fwrite (bufpos, sizeof(char), mblength, stdout);
+	    }
+	}
+      buflen -= mblength;
+      bufpos += mblength;
+    }
+}
+#endif
+
+
 void
 usage (int status)
 {
@@ -524,7 +743,12 @@
 
   file_list = (optind < argc ? &argv[optind] : stdin_argv);
 
-  unexpand ();
+#if HAVE_MBRTOWC
+  if (MB_CUR_MAX > 1)
+    unexpand_multibyte ();
+  else
+#endif
+    unexpand ();
 
   if (have_read_stdin && fclose (stdin) != 0)
     error (EXIT_FAILURE, errno, "-");
diff -Naur coreutils-8.19.orig/src/uniq.c coreutils-8.19/src/uniq.c
--- coreutils-8.19.orig/src/uniq.c	2012-07-21 09:54:31.000000000 -0500
+++ coreutils-8.19/src/uniq.c	2012-08-20 21:50:40.000000000 -0500
@@ -21,6 +21,16 @@
 #include <getopt.h>
 #include <sys/types.h>
 
+/* Get mbstate_t, mbrtowc(). */
+#if HAVE_WCHAR_H
+# include <wchar.h>
+#endif
+
+/* Get isw* functions. */
+#if HAVE_WCTYPE_H
+# include <wctype.h>
+#endif
+
 #include "system.h"
 #include "argmatch.h"
 #include "linebuffer.h"
@@ -32,7 +42,19 @@
 #include "stdio--.h"
 #include "xmemcoll.h"
 #include "xstrtol.h"
-#include "memcasecmp.h"
+#include "xmemcoll.h"
+
+/* MB_LEN_MAX is incorrectly defined to be 1 in at least one GCC
+   installation; work around this configuration error.  */
+#if !defined MB_LEN_MAX || MB_LEN_MAX < 2
+# define MB_LEN_MAX 16
+#endif
+
+/* Some systems, like BeOS, have multibyte encodings but lack mbstate_t.  */
+#if HAVE_MBRTOWC && defined mbstate_t
+# define mbrtowc(pwc, s, n, ps) (mbrtowc) (pwc, s, n, 0)
+#endif
+
 
 /* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "uniq"
@@ -108,6 +130,10 @@
 /* Select whether/how to delimit groups of duplicate lines.  */
 static enum delimit_method delimit_groups;
 
+/* Function pointers. */
+static char *
+(*find_field) (struct linebuffer *line);
+
 static struct option const longopts[] =
 {
   {"count", no_argument, NULL, 'c'},
@@ -206,7 +232,7 @@
    return a pointer to the beginning of the line's field to be compared. */
 
 static char * _GL_ATTRIBUTE_PURE
-find_field (struct linebuffer const *line)
+find_field_uni (struct linebuffer *line)
 {
   size_t count;
   char const *lp = line->buffer;
@@ -226,6 +252,83 @@
   return line->buffer + i;
 }
 
+#if HAVE_MBRTOWC
+
+# define MBCHAR_TO_WCHAR(WC, MBLENGTH, LP, POS, SIZE, STATEP, CONVFAIL)  \
+  do                                                                        \
+    {                                                                        \
+      mbstate_t state_bak;                                                \
+                                                                        \
+      CONVFAIL = 0;                                                        \
+      state_bak = *STATEP;                                                \
+                                                                        \
+      MBLENGTH = mbrtowc (&WC, LP + POS, SIZE - POS, STATEP);                \
+                                                                        \
+      switch (MBLENGTH)                                                        \
+        {                                                                \
+        case (size_t)-2:                                                \
+        case (size_t)-1:                                                \
+          *STATEP = state_bak;                                                \
+          CONVFAIL++;                                                        \
+          /* Fall through */                                                \
+        case 0:                                                                \
+          MBLENGTH = 1;                                                        \
+        }                                                                \
+    }                                                                        \
+  while (0)
+
+static char *
+find_field_multi (struct linebuffer *line)
+{
+  size_t count;
+  char *lp = line->buffer;
+  size_t size = line->length - 1;
+  size_t pos;
+  size_t mblength;
+  wchar_t wc;
+  mbstate_t *statep;
+  int convfail = 0;
+
+  pos = 0;
+  statep = &(line->state);
+
+  /* skip fields. */
+  for (count = 0; count < skip_fields && pos < size; count++)
+    {
+      while (pos < size)
+        {
+          MBCHAR_TO_WCHAR (wc, mblength, lp, pos, size, statep, convfail);
+ 
+          if (convfail || !iswblank (wc))
+            {
+              pos += mblength;
+              break;
+            }
+          pos += mblength;
+        }
+
+      while (pos < size)
+        {
+          MBCHAR_TO_WCHAR (wc, mblength, lp, pos, size, statep, convfail);
+
+          if (!convfail && iswblank (wc))
+            break;
+
+          pos += mblength;
+        }
+    }
+
+  /* skip fields. */
+  for (count = 0; count < skip_chars && pos < size; count++)
+    {
+      MBCHAR_TO_WCHAR (wc, mblength, lp, pos, size, statep, convfail);
+      pos += mblength;
+    }
+
+  return lp + pos;
+}
+#endif
+
 /* Return false if two strings OLD and NEW match, true if not.
    OLD and NEW point not to the beginnings of the lines
    but rather to the beginnings of the fields to compare.
@@ -234,6 +337,8 @@
 static bool
 different (char *old, char *new, size_t oldlen, size_t newlen)
 {
+  char *copy_old, *copy_new;
+
   if (check_chars < oldlen)
     oldlen = check_chars;
   if (check_chars < newlen)
@@ -241,15 +346,93 @@
 
   if (ignore_case)
     {
-      /* FIXME: This should invoke strcoll somehow.  */
-      return oldlen != newlen || memcasecmp (old, new, oldlen);
+      size_t i;
+
+      copy_old = alloca (oldlen + 1);
+      copy_new = alloca (oldlen + 1);
+
+      for (i = 0; i < oldlen; i++)
+        {
+          copy_old[i] = toupper (old[i]);
+          copy_new[i] = toupper (new[i]);
+        }
     }
-  else if (hard_LC_COLLATE)
-    return xmemcoll (old, oldlen, new, newlen) != 0;
   else
-    return oldlen != newlen || memcmp (old, new, oldlen);
+    {
+      copy_old = (char *)old;
+      copy_new = (char *)new;
+    }
+
+  return xmemcoll (copy_old, oldlen, copy_new, newlen);
 }
 
+#if HAVE_MBRTOWC
+static int
+different_multi (const char *old, const char *new, size_t oldlen, size_t newlen, mbstate_t oldstate, mbstate_t newstate)
+{
+  size_t i, j, chars;
+  const char *str[2];
+  char *copy[2];
+  size_t len[2];
+  mbstate_t state[2];
+  size_t mblength;
+  wchar_t wc, uwc;
+  mbstate_t state_bak;
+
+  str[0] = old;
+  str[1] = new;
+  len[0] = oldlen;
+  len[1] = newlen;
+  state[0] = oldstate;
+  state[1] = newstate;
+
+  for (i = 0; i < 2; i++)
+    {
+      copy[i] = alloca (len[i] + 1);
+
+      for (j = 0, chars = 0; j < len[i] && chars < check_chars; chars++)
+        {
+          state_bak = state[i];
+          mblength = mbrtowc (&wc, str[i] + j, len[i] - j, &(state[i]));
+
+          switch (mblength)
+            {
+            case (size_t)-1:
+            case (size_t)-2:
+              state[i] = state_bak;
+              /* Fall through */
+            case 0:
+              mblength = 1;
+              break;
+
+            default:
+              if (ignore_case)
+                {
+                  uwc = towupper (wc);
+
+                  if (uwc != wc)
+                    {
+                      mbstate_t state_wc;
+
+                      memset (&state_wc, '\0', sizeof(mbstate_t));
+                      wcrtomb (copy[i] + j, uwc, &state_wc);
+                    }
+                  else
+                    memcpy (copy[i] + j, str[i] + j, mblength);
+                }
+              else
+                memcpy (copy[i] + j, str[i] + j, mblength);
+            }
+          j += mblength;
+        }
+      copy[i][j] = '\0';
+      len[i] = j;
+    }
+
+  return xmemcoll (copy[0], len[0], copy[1], len[1]);
+}
+#endif
+
 /* Output the line in linebuffer LINE to standard output
    provided that the switches say it should be output.
    MATCH is true if the line matches the previous line.
@@ -304,15 +487,43 @@
     {
       char *prevfield IF_LINT ( = NULL);
       size_t prevlen IF_LINT ( = 0);
+#if HAVE_MBRTOWC
+      mbstate_t prevstate;
+
+      memset (&prevstate, '\0', sizeof (mbstate_t));
+#endif
 
       while (!feof (stdin))
         {
           char *thisfield;
           size_t thislen;
+#if HAVE_MBRTOWC
+          mbstate_t thisstate;
+#endif
+
           if (readlinebuffer_delim (thisline, stdin, delimiter) == 0)
             break;
           thisfield = find_field (thisline);
           thislen = thisline->length - 1 - (thisfield - thisline->buffer);
+#if HAVE_MBRTOWC
+          if (MB_CUR_MAX > 1)
+            {
+            thisstate = thisline->state;
+
+            if (prevline->length == 0 || different_multi
+              (thisfield, prevfield, thislen, prevlen, thisstate, prevstate))
+              {
+                fwrite (thisline->buffer, sizeof (char),
+                        thisline->length, stdout);
+
+                SWAP_LINES (prevline, thisline);
+                prevfield = thisfield;
+                prevlen = thislen;
+                prevstate = thisstate;
+              }
+          }
+        else
+#endif
           if (prevline->length == 0
               || different (thisfield, prevfield, thislen, prevlen))
             {
@@ -331,17 +542,26 @@
       size_t prevlen;
       uintmax_t match_count = 0;
       bool first_delimiter = true;
+#if HAVE_MBRTOWC
+      mbstate_t prevstate;
+#endif
 
       if (readlinebuffer_delim (prevline, stdin, delimiter) == 0)
         goto closefiles;
       prevfield = find_field (prevline);
       prevlen = prevline->length - 1 - (prevfield - prevline->buffer);
+#if HAVE_MBRTOWC
+      prevstate = prevline->state;
+#endif
 
       while (!feof (stdin))
         {
           bool match;
           char *thisfield;
           size_t thislen;
+#if HAVE_MBRTOWC
+          mbstate_t thisstate = thisline->state;
+#endif
           if (readlinebuffer_delim (thisline, stdin, delimiter) == 0)
             {
               if (ferror (stdin))
@@ -350,6 +570,14 @@
             }
           thisfield = find_field (thisline);
           thislen = thisline->length - 1 - (thisfield - thisline->buffer);
+#if HAVE_MBRTOWC
+          if (MB_CUR_MAX > 1)
+            {
+              match = !different_multi (thisfield, prevfield,
+                                thislen, prevlen, thisstate, prevstate);
+            }
+          else
+#endif
           match = !different (thisfield, prevfield, thislen, prevlen);
           match_count += match;
 
@@ -382,6 +610,9 @@
               SWAP_LINES (prevline, thisline);
               prevfield = thisfield;
               prevlen = thislen;
+#if HAVE_MBRTOWC
+              prevstate = thisstate;
+#endif
               if (!match)
                 match_count = 0;
             }
@@ -427,6 +658,19 @@
 
   atexit (close_stdout);
 
+#if HAVE_MBRTOWC
+  if (MB_CUR_MAX > 1)
+    {
+      find_field = find_field_multi;
+    }
+  else
+#endif
+    {
+      find_field = find_field_uni;
+    }
+
+
+
   skip_chars = 0;
   skip_fields = 0;
   check_chars = SIZE_MAX;
diff -Naur coreutils-8.19.orig/tests/Makefile.am coreutils-8.19/tests/Makefile.am
--- coreutils-8.19.orig/tests/Makefile.am	2012-08-18 01:02:47.000000000 -0500
+++ coreutils-8.19/tests/Makefile.am	2012-08-20 21:50:40.000000000 -0500
@@ -248,6 +248,7 @@
   misc/sort-debug-warn				\
   misc/sort-discrim				\
   misc/sort-files0-from				\
+  misc/sort-mb-tests				\
   misc/sort-float				\
   misc/sort-merge				\
   misc/sort-merge-fdlimit			\
@@ -551,6 +552,10 @@
   $(root_tests)
 
 pr_data =					\
+  misc/mb1.X			\
+  misc/mb1.I			\
+  misc/mb2.X			\
+  misc/mb2.I			\
   pr/0F						\
   pr/0FF					\
   pr/0FFnt					\
diff -Naur coreutils-8.19.orig/tests/Makefile.in coreutils-8.19/tests/Makefile.in
--- coreutils-8.19.orig/tests/Makefile.in	2012-08-18 01:03:23.000000000 -0500
+++ coreutils-8.19/tests/Makefile.in	2012-08-20 21:50:40.000000000 -0500
@@ -3891,6 +3891,13 @@
 	--log-file $$b.log --trs-file $$b.trs \
 	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
 	"$$tst" $(AM_TESTS_FD_REDIRECT)
+misc/sort-mb-tests.log: misc/sort-mb-tests
+	@p='misc/sort-mb-tests'; \
+	b='misc/sort-mb-tests'; \
+	$(am__check_pre) $(LOG_DRIVER) --test-name "$$f" \
+	--log-file $$b.log --trs-file $$b.trs \
+	$(am__common_driver_flags) $(AM_LOG_DRIVER_FLAGS) $(LOG_DRIVER_FLAGS) -- $(LOG_COMPILE) \
+	"$$tst" $(AM_TESTS_FD_REDIRECT)
 misc/sort-merge.log: misc/sort-merge
 	@p='misc/sort-merge'; \
 	b='misc/sort-merge'; \
diff -Naur coreutils-8.19.orig/tests/misc/cut coreutils-8.19/tests/misc/cut
--- coreutils-8.19.orig/tests/misc/cut	2012-07-21 09:54:31.000000000 -0500
+++ coreutils-8.19/tests/misc/cut	2012-08-20 21:50:40.000000000 -0500
@@ -23,14 +23,15 @@
 # Turn off localization of executable's output.
 @ENV{qw(LANGUAGE LANG LC_ALL)} = ('C') x 3;
 
-my $mb_locale = $ENV{LOCALE_FR_UTF8};
-! defined $mb_locale || $mb_locale eq 'none'
-  and $mb_locale = 'C';
+#my $mb_locale = $ENV{LOCALE_FR_UTF8};
+#! defined $mb_locale || $mb_locale eq 'none'
+#  and $mb_locale = 'C';
+my $mb_locale = 'C';
 
 my $prog = 'cut';
 my $try = "Try '$prog --help' for more information.\n";
 my $from_1 = "$prog: fields and positions are numbered from 1\n$try";
-my $inval = "$prog: invalid byte or field list\n$try";
+my $inval = "$prog: invalid byte, character or field list\n$try";
 my $no_endpoint = "$prog: invalid range with no endpoint: -\n$try";
 
 my @Tests =
@@ -147,7 +148,7 @@
 
   # None of the following invalid ranges provoked an error up to coreutils-6.9.
   ['inval1', qw(-f 2-0), {IN=>''}, {OUT=>''}, {EXIT=>1},
-   {ERR=>"$prog: invalid decreasing range\n$try"}],
+   {ERR=>"$prog: invalid byte, character or field list\n$try"}],
   ['inval2', qw(-f -), {IN=>''}, {OUT=>''}, {EXIT=>1}, {ERR=>$no_endpoint}],
   ['inval3', '-f', '4,-', {IN=>''}, {OUT=>''}, {EXIT=>1}, {ERR=>$no_endpoint}],
   ['inval4', '-f', '1-2,-', {IN=>''}, {OUT=>''}, {EXIT=>1},
diff -Naur coreutils-8.19.orig/tests/misc/mb1.I coreutils-8.19/tests/misc/mb1.I
--- coreutils-8.19.orig/tests/misc/mb1.I	1969-12-31 18:00:00.000000000 -0600
+++ coreutils-8.19/tests/misc/mb1.I	2012-08-20 21:50:40.000000000 -0500
@@ -0,0 +1,4 @@
+Apple＠10
+Banana＠5
+Citrus＠20
+Cherry＠30
diff -Naur coreutils-8.19.orig/tests/misc/mb1.X coreutils-8.19/tests/misc/mb1.X
--- coreutils-8.19.orig/tests/misc/mb1.X	1969-12-31 18:00:00.000000000 -0600
+++ coreutils-8.19/tests/misc/mb1.X	2012-08-20 21:50:40.000000000 -0500
@@ -0,0 +1,4 @@
+Banana＠5
+Apple＠10
+Citrus＠20
+Cherry＠30
diff -Naur coreutils-8.19.orig/tests/misc/mb2.I coreutils-8.19/tests/misc/mb2.I
--- coreutils-8.19.orig/tests/misc/mb2.I	1969-12-31 18:00:00.000000000 -0600
+++ coreutils-8.19/tests/misc/mb2.I	2012-08-20 21:50:40.000000000 -0500
@@ -0,0 +1,4 @@
+Apple＠ＡＡ10＠＠20
+Banana＠ＡＡ5＠＠30
+Citrus＠ＡＡ20＠＠5
+Cherry＠ＡＡ30＠＠10
diff -Naur coreutils-8.19.orig/tests/misc/mb2.X coreutils-8.19/tests/misc/mb2.X
--- coreutils-8.19.orig/tests/misc/mb2.X	1969-12-31 18:00:00.000000000 -0600
+++ coreutils-8.19/tests/misc/mb2.X	2012-08-20 21:50:40.000000000 -0500
@@ -0,0 +1,4 @@
+Citrus＠ＡＡ20＠＠5
+Cherry＠ＡＡ30＠＠10
+Apple＠ＡＡ10＠＠20
+Banana＠ＡＡ5＠＠30
diff -Naur coreutils-8.19.orig/tests/misc/sort-mb-tests coreutils-8.19/tests/misc/sort-mb-tests
--- coreutils-8.19.orig/tests/misc/sort-mb-tests	1969-12-31 18:00:00.000000000 -0600
+++ coreutils-8.19/tests/misc/sort-mb-tests	2012-08-20 21:50:40.000000000 -0500
@@ -0,0 +1,58 @@
+#! /bin/sh
+case $# in
+  0) xx='../src/sort';;
+  *) xx="$1";;
+esac
+test "$VERBOSE" && echo=echo || echo=:
+$echo testing program: $xx
+errors=0
+test "$srcdir" || srcdir=.
+test "$VERBOSE" && $xx --version 2> /dev/null
+
+export LC_ALL=en_US.UTF-8
+locale -k LC_CTYPE 2>&1 | grep -q charmap.*UTF-8 || exit 77
+errors=0
+
+$xx -t ＠ -k2 -n misc/mb1.I > misc/mb1.O
+code=$?
+if test $code != 0; then
+  $echo "Test mb1 failed: $xx return code $code differs from expected value 0"
+  errors=`expr $errors + 1`
+else
+  cmp misc/mb1.O $srcdir/misc/mb1.X > /dev/null 2>&1
+  case $? in
+    0) if test "$VERBOSE"; then $echo "passed mb1"; fi;;
+    1) $echo "Test mb1 failed: files misc/mb1.O and $srcdir/misc/mb1.X differ" 1>&2
+       (diff -c misc/mb1.O $srcdir/misc/mb1.X) 2> /dev/null
+       errors=`expr $errors + 1`;;
+    2) $echo "Test mb1 may have failed." 1>&2
+       $echo The command "cmp misc/mb1.O $srcdir/misc/mb1.X" failed. 1>&2
+       errors=`expr $errors + 1`;;
+  esac
+fi
+
+$xx -t ＠ -k4 -n misc/mb2.I > misc/mb2.O
+code=$?
+if test $code != 0; then
+  $echo "Test mb2 failed: $xx return code $code differs from expected value 0" 1>&2
+  errors=`expr $errors + 1`
+else
+  cmp misc/mb2.O $srcdir/misc/mb2.X > /dev/null 2>&1
+  case $? in
+    0) if test "$VERBOSE"; then $echo "passed mb2"; fi;;
+    1) $echo "Test mb2 failed: files misc/mb2.O and $srcdir/misc/mb2.X differ" 1>&2
+       (diff -c misc/mb2.O $srcdir/misc/mb2.X) 2> /dev/null
+       errors=`expr $errors + 1`;;
+    2) $echo "Test mb2 may have failed." 1>&2
+       $echo The command "cmp misc/mb2.O $srcdir/misc/mb2.X" failed. 1>&2
+       errors=`expr $errors + 1`;;
+  esac
+fi
+
+if test $errors = 0; then
+  $echo Passed all 113 tests. 1>&2
+else
+  $echo Failed $errors tests. 1>&2
+fi
+test $errors = 0 || errors=1
+exit $errors
