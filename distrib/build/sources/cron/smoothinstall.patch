--- cron-3.0pl1.orig/database.c.orig	2026-02-08 00:35:46.057519258 -0500
+++ cron-3.0pl1.orig/database.c	2026-02-08 00:45:49.000000000 -0500
@@ -25,6 +25,7 @@
 
 #include "cron.h"
 #include <fcntl.h>
+#include <glob.h>
 #include <sys/stat.h>
 #include <sys/file.h>
 #include <time.h>
@@ -166,42 +167,58 @@
 	}
 
 	/* Read all the package crontabs. */
-	if (!(dir = opendir(SYSCRONDIR))) {
-		log_it("CRON", getpid(), "OPENDIR FAILED", SYSCRONDIR);
-	}
+	/* Smoothwall additions adapted from Steve McNeill's SmoothInstall work. */
 
-	while (dir != NULL && NULL != (dp = readdir(dir))) {
-		char	fname[MAXNAMLEN+1],
-			tabname[PATH_MAX+1];
+	int i;
+	glob_t cronDotD;
 
+	/* First get /etc/cron.d/ */
+	glob(SYSCRONDIR, GLOB_ONLYDIR|GLOB_NOMAGIC, NULL, &cronDotD);
+	/* Now get all the mods' cron.d/ dirs */
+	glob("/var/smoothwall/mods/*/etc/cron.d", GLOB_ONLYDIR|GLOB_APPEND, NULL, &cronDotD);
+		
+	for (i=0; i<cronDotD.gl_pathc; i++) {
+		log_it( "CRON", getpid(), "Processing ", cronDotD.gl_pathv[i]);
+ 
+		if (!(dir = opendir(cronDotD.gl_pathv[i]))) {
+			log_it("CRON", getpid(), "OPENDIR FAILED", cronDotD.gl_pathv[i]);
+		}
 
-		/* avoid file names beginning with ".".  this is good
-		 * because we would otherwise waste two guaranteed calls
-		 * to stat() for . and .., and also because package names
-		 * starting with a period are just too nasty to consider.
-		 */
-		if (dp->d_name[0] == '.')
+		while (dir != NULL && NULL != (dp = readdir(dir))) {
+			char	fname[MAXNAMLEN+1],
+				tabname[PATH_MAX+1];
+
+
+			/* avoid file names beginning with ".".  this is good
+			* because we would otherwise waste two guaranteed calls
+			* to stat() for . and .., and also because package names
+			* starting with a period are just too nasty to consider.
+			*/
+			if (dp->d_name[0] == '.')
+				continue;
+
+			/* skip file names with letters outside the set
+			* [A-Za-z0-9_-], like run-parts.
+			*/
+			if (!valid_name(dp->d_name))
 			continue;
 
-		/* skipfile names with letters outside the set
-		 * [A-Za-z0-9_-], like run-parts.
-		 */
-		if (!valid_name(dp->d_name))
-		  continue;
-
 		/* Generate the "fname" */
-		(void) strcpy(fname,"*system*");
-		(void) strcat(fname, dp->d_name);
-		sprintf(tabname,"%s/%s", SYSCRONDIR, dp->d_name);
-
-		/* statbuf is used as working storage by process_crontab() --
-		   current contents are irrelevant */
-		process_crontab(SYSUSERNAME, fname, tabname,
-				&statbuf, &new_db, old_db);
+			(void) strcpy(fname,"*system*");
+			(void) strcat(fname, dp->d_name);
+			sprintf(tabname,"%s/%s", cronDotD.gl_pathv[i], dp->d_name);
+
+			/* statbuf is used as working storage by process_crontab() --
+			current contents are irrelevant */
+			process_crontab(SYSUSERNAME, fname, tabname,
+					&statbuf, &new_db, old_db);
+ 
+		}
+		if (dir)
+			closedir(dir);
 
 	}
-	if (dir)
-		closedir(dir);
+	globfree(&cronDotD);
 
 	/* we used to keep this dir open all the time, for the sake of
 	 * efficiency.  however, we need to close it in every fork, and
